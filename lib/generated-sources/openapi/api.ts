/* tslint:disable */
/* eslint-disable */
/**
 * Stair Crusher Club Admin API Specification
 * ## 계단정복지도 서비스의 서버 - 어드민 통신을 위한 API 명세. 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccessibilityAllowedRegionDTO
 */
export interface AccessibilityAllowedRegionDTO {
    /**
     * 
     * @type {string}
     * @memberof AccessibilityAllowedRegionDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AccessibilityAllowedRegionDTO
     */
    'name'?: string;
    /**
     * 
     * @type {Array<LocationDTO>}
     * @memberof AccessibilityAllowedRegionDTO
     */
    'boundaryVertices': Array<LocationDTO>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AccessibilityTypeDTO = {
    Place: 'Place',
    Building: 'Building',
    PlaceReview: 'PlaceReview',
    ToiletReview: 'ToiletReview',
    Unknown: 'UNKNOWN'
} as const;

export type AccessibilityTypeDTO = typeof AccessibilityTypeDTO[keyof typeof AccessibilityTypeDTO];


/**
 * 
 * @export
 * @interface AdminAccessibilityDTO
 */
export interface AdminAccessibilityDTO {
    /**
     * 
     * @type {AdminPlaceAccessibilityDTO}
     * @memberof AdminAccessibilityDTO
     */
    'placeAccessibility': AdminPlaceAccessibilityDTO;
    /**
     * 
     * @type {AdminBuildingAccessibilityDTO}
     * @memberof AdminAccessibilityDTO
     */
    'buildingAccessibility'?: AdminBuildingAccessibilityDTO;
}
/**
 * 
 * @export
 * @interface AdminAccessibilityInspectionResultDTO
 */
export interface AdminAccessibilityInspectionResultDTO {
    /**
     * 
     * @type {string}
     * @memberof AdminAccessibilityInspectionResultDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AdminAccessibilityInspectionResultDTO
     */
    'accessibilityId': string;
    /**
     * 
     * @type {AccessibilityTypeDTO}
     * @memberof AdminAccessibilityInspectionResultDTO
     */
    'accessibilityType': AccessibilityTypeDTO;
    /**
     * 
     * @type {string}
     * @memberof AdminAccessibilityInspectionResultDTO
     */
    'inspectorId': string;
    /**
     * 
     * @type {InspectorTypeDTO}
     * @memberof AdminAccessibilityInspectionResultDTO
     */
    'inspectorType': InspectorTypeDTO;
    /**
     * 
     * @type {ResultTypeDTO}
     * @memberof AdminAccessibilityInspectionResultDTO
     */
    'resultType': ResultTypeDTO;
    /**
     * 검증 결과 내용 (JSON)
     * @type {string}
     * @memberof AdminAccessibilityInspectionResultDTO
     */
    'contents': string;
    /**
     * 
     * @type {Array<AdminImageDTO>}
     * @memberof AdminAccessibilityInspectionResultDTO
     */
    'images': Array<AdminImageDTO>;
    /**
     * 접근성 대상의 이름 (Place인 경우 장소명, Building인 경우 건물명)
     * @type {string}
     * @memberof AdminAccessibilityInspectionResultDTO
     */
    'accessibilityName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AdminAccessibilityInspectionResultDTO
     */
    'handledAtMillis'?: number | null;
    /**
     * 검수 결과 반영 상태 (APPLIED, ERROR)
     * @type {ApplyStateDto}
     * @memberof AdminAccessibilityInspectionResultDTO
     */
    'applyState'?: ApplyStateDto | null;
    /**
     * 
     * @type {number}
     * @memberof AdminAccessibilityInspectionResultDTO
     */
    'createdAtMillis': number;
    /**
     * 
     * @type {number}
     * @memberof AdminAccessibilityInspectionResultDTO
     */
    'updatedAtMillis': number;
}
/**
 * Place를 SubBuilding에 할당한 결과
 * @export
 * @interface AdminAssignPlacesToSubBuildingsResponseDTO
 */
export interface AdminAssignPlacesToSubBuildingsResponseDTO {
    /**
     * 대상 Building의 전체 Place 수
     * @type {number}
     * @memberof AdminAssignPlacesToSubBuildingsResponseDTO
     */
    'totalPlaces': number;
    /**
     * SubBuilding에 할당된 Place 수
     * @type {number}
     * @memberof AdminAssignPlacesToSubBuildingsResponseDTO
     */
    'assignedCount': number;
    /**
     * 어떤 SubBuilding에도 할당되지 않은 Place 수
     * @type {number}
     * @memberof AdminAssignPlacesToSubBuildingsResponseDTO
     */
    'unassignedCount': number;
    /**
     * 결과 메시지
     * @type {string}
     * @memberof AdminAssignPlacesToSubBuildingsResponseDTO
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface AdminBannerDTO
 */
export interface AdminBannerDTO {
    /**
     * 
     * @type {string}
     * @memberof AdminBannerDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AdminBannerDTO
     */
    'loggingKey': string;
    /**
     * 
     * @type {string}
     * @memberof AdminBannerDTO
     */
    'imageUrl': string;
    /**
     * 
     * @type {string}
     * @memberof AdminBannerDTO
     */
    'clickPageUrl': string;
    /**
     * 
     * @type {string}
     * @memberof AdminBannerDTO
     */
    'clickPageTitle': string;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminBannerDTO
     */
    'startAt'?: EpochMillisTimestamp;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminBannerDTO
     */
    'endAt'?: EpochMillisTimestamp;
    /**
     * 
     * @type {number}
     * @memberof AdminBannerDTO
     */
    'displayOrder': number;
    /**
     * 
     * @type {HomeBannerTypeDTO}
     * @memberof AdminBannerDTO
     */
    'bannerType': HomeBannerTypeDTO;
}
/**
 * 
 * @export
 * @interface AdminBuildingAccessibilityDTO
 */
export interface AdminBuildingAccessibilityDTO {
    /**
     * 
     * @type {string}
     * @memberof AdminBuildingAccessibilityDTO
     */
    'id': string;
    /**
     * 
     * @type {AdminStairInfoDTO}
     * @memberof AdminBuildingAccessibilityDTO
     */
    'entranceStairInfo': AdminStairInfoDTO;
    /**
     * 
     * @type {AdminStairHeightLevel}
     * @memberof AdminBuildingAccessibilityDTO
     */
    'entranceStairHeightLevel'?: AdminStairHeightLevel;
    /**
     * 
     * @type {Array<AdminEntranceDoorType>}
     * @memberof AdminBuildingAccessibilityDTO
     */
    'entranceDoorTypes'?: Array<AdminEntranceDoorType>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AdminBuildingAccessibilityDTO
     * @deprecated
     */
    'entranceImageUrls': Array<string>;
    /**
     * 
     * @type {Array<AdminImageDTO>}
     * @memberof AdminBuildingAccessibilityDTO
     */
    'entranceImages': Array<AdminImageDTO>;
    /**
     * 
     * @type {boolean}
     * @memberof AdminBuildingAccessibilityDTO
     */
    'hasSlope': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AdminBuildingAccessibilityDTO
     */
    'hasElevator': boolean;
    /**
     * 
     * @type {AdminStairInfoDTO}
     * @memberof AdminBuildingAccessibilityDTO
     */
    'elevatorStairInfo': AdminStairInfoDTO;
    /**
     * 
     * @type {AdminStairHeightLevel}
     * @memberof AdminBuildingAccessibilityDTO
     */
    'elevatorStairHeightLevel'?: AdminStairHeightLevel;
    /**
     * 
     * @type {Array<string>}
     * @memberof AdminBuildingAccessibilityDTO
     * @deprecated
     */
    'elevatorImageUrls': Array<string>;
    /**
     * 
     * @type {Array<AdminImageDTO>}
     * @memberof AdminBuildingAccessibilityDTO
     */
    'elevatorImages': Array<AdminImageDTO>;
    /**
     * 
     * @type {string}
     * @memberof AdminBuildingAccessibilityDTO
     */
    'buildingName'?: string;
    /**
     * 익명으로 등록되었으면 null.
     * @type {string}
     * @memberof AdminBuildingAccessibilityDTO
     */
    'registeredUserName'?: string;
    /**
     * 
     * @type {number}
     * @memberof AdminBuildingAccessibilityDTO
     */
    'createdAtMillis': number;
}
/**
 * 
 * @export
 * @interface AdminBuildingDeduplicationCandidateDTO
 */
export interface AdminBuildingDeduplicationCandidateDTO {
    /**
     * 
     * @type {string}
     * @memberof AdminBuildingDeduplicationCandidateDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AdminBuildingDeduplicationCandidateDTO
     */
    'building1Id': string;
    /**
     * 
     * @type {string}
     * @memberof AdminBuildingDeduplicationCandidateDTO
     */
    'building2Id': string;
    /**
     * 
     * @type {number}
     * @memberof AdminBuildingDeduplicationCandidateDTO
     */
    'distanceInMeters': number;
    /**
     * 
     * @type {string}
     * @memberof AdminBuildingDeduplicationCandidateDTO
     */
    'building1Name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminBuildingDeduplicationCandidateDTO
     */
    'building2Name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminBuildingDeduplicationCandidateDTO
     */
    'normalizedAddress': string;
    /**
     * 
     * @type {LocationDTO}
     * @memberof AdminBuildingDeduplicationCandidateDTO
     */
    'building1Location': LocationDTO;
    /**
     * 
     * @type {LocationDTO}
     * @memberof AdminBuildingDeduplicationCandidateDTO
     */
    'building2Location': LocationDTO;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminBuildingDeduplicationCandidateDTO
     */
    'acceptedAt'?: EpochMillisTimestamp;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminBuildingDeduplicationCandidateDTO
     */
    'ignoredAt'?: EpochMillisTimestamp;
    /**
     * 
     * @type {string}
     * @memberof AdminBuildingDeduplicationCandidateDTO
     */
    'canonicalBuildingId'?: string;
}
/**
 * Building Division 정보
 * @export
 * @interface AdminBuildingDivisionDTO
 */
export interface AdminBuildingDivisionDTO {
    /**
     * Building Division ID
     * @type {string}
     * @memberof AdminBuildingDivisionDTO
     */
    'id': string;
    /**
     * 충돌이 발생한 Building ID
     * @type {string}
     * @memberof AdminBuildingDivisionDTO
     */
    'buildingId': string;
    /**
     * 
     * @type {LocationDTO}
     * @memberof AdminBuildingDivisionDTO
     */
    'buildingLocation': LocationDTO;
    /**
     * 도로명 주소
     * @type {string}
     * @memberof AdminBuildingDivisionDTO
     */
    'roadAddress': string;
    /**
     * 
     * @type {AdminBuildingDivisionStatusDTO}
     * @memberof AdminBuildingDivisionDTO
     */
    'status': AdminBuildingDivisionStatusDTO;
    /**
     * 분할 사유
     * @type {string}
     * @memberof AdminBuildingDivisionDTO
     */
    'divisionReason'?: string;
    /**
     * 생성된 SubBuilding 개수
     * @type {number}
     * @memberof AdminBuildingDivisionDTO
     */
    'subBuildingsCount'?: number;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminBuildingDivisionDTO
     */
    'confirmedAt'?: EpochMillisTimestamp;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminBuildingDivisionDTO
     */
    'ignoredAt'?: EpochMillisTimestamp;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminBuildingDivisionDTO
     */
    'createdAt': EpochMillisTimestamp;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminBuildingDivisionDTO
     */
    'updatedAt': EpochMillisTimestamp;
}
/**
 * Building Division 상세 정보 (SubBuilding 목록 포함)
 * @export
 * @interface AdminBuildingDivisionDetailDTO
 */
export interface AdminBuildingDivisionDetailDTO {
    /**
     * 
     * @type {AdminBuildingDivisionDTO}
     * @memberof AdminBuildingDivisionDetailDTO
     */
    'division': AdminBuildingDivisionDTO;
    /**
     * SubBuilding 목록
     * @type {Array<AdminSubBuildingDTO>}
     * @memberof AdminBuildingDivisionDetailDTO
     */
    'subBuildings': Array<AdminSubBuildingDTO>;
}
/**
 * Building Division 상태 - PENDING: 대기 중 (관리자 검토 필요) - CONFIRMED: 확정됨 (분할 필요, SubBuilding 관리 가능) - IGNORED: 무시됨 (분할 불필요) 
 * @export
 * @enum {string}
 */

export const AdminBuildingDivisionStatusDTO = {
    Pending: 'PENDING',
    Confirmed: 'CONFIRMED',
    Ignored: 'IGNORED'
} as const;

export type AdminBuildingDivisionStatusDTO = typeof AdminBuildingDivisionStatusDTO[keyof typeof AdminBuildingDivisionStatusDTO];


/**
 * 
 * @export
 * @interface AdminChallengeActionConditionDTO
 */
export interface AdminChallengeActionConditionDTO {
    /**
     * 
     * @type {Array<AdminChallengeActionConditionTypeEnumDTO>}
     * @memberof AdminChallengeActionConditionDTO
     */
    'types'?: Array<AdminChallengeActionConditionTypeEnumDTO>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AdminChallengeActionConditionTypeEnumDTO = {
    BuildingAccessibility: 'BUILDING_ACCESSIBILITY',
    BuildingAccessibilityComment: 'BUILDING_ACCESSIBILITY_COMMENT',
    PlaceAccessibility: 'PLACE_ACCESSIBILITY',
    PlaceAccessibilityComment: 'PLACE_ACCESSIBILITY_COMMENT',
    PlaceReview: 'PLACE_REVIEW'
} as const;

export type AdminChallengeActionConditionTypeEnumDTO = typeof AdminChallengeActionConditionTypeEnumDTO[keyof typeof AdminChallengeActionConditionTypeEnumDTO];


/**
 * 
 * @export
 * @interface AdminChallengeAddressConditionDTO
 */
export interface AdminChallengeAddressConditionDTO {
    /**
     * 
     * @type {Array<string>}
     * @memberof AdminChallengeAddressConditionDTO
     */
    'rawEupMyeonDongs'?: Array<string>;
}
/**
 * 
 * @export
 * @interface AdminChallengeB2bFormSchemaAvailableFieldDTO
 */
export interface AdminChallengeB2bFormSchemaAvailableFieldDTO {
    /**
     * 
     * @type {AdminChallengeB2bFormSchemaAvailableFieldNameEnumDTO}
     * @memberof AdminChallengeB2bFormSchemaAvailableFieldDTO
     */
    'name'?: AdminChallengeB2bFormSchemaAvailableFieldNameEnumDTO;
    /**
     * Custom 질문의 불변 key (camelCase, built-in인 경우 null)
     * @type {string}
     * @memberof AdminChallengeB2bFormSchemaAvailableFieldDTO
     */
    'key'?: string | null;
    /**
     * 질문명 override (built-in인 경우 선택, custom인 경우 필수)
     * @type {string}
     * @memberof AdminChallengeB2bFormSchemaAvailableFieldDTO
     */
    'customDisplayName'?: string | null;
    /**
     * 객관식 옵션 (null이면 주관식)
     * @type {Array<string>}
     * @memberof AdminChallengeB2bFormSchemaAvailableFieldDTO
     */
    'options'?: Array<string> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AdminChallengeB2bFormSchemaAvailableFieldNameEnumDTO = {
    ParticipantName: 'PARTICIPANT_NAME',
    CompanyName: 'COMPANY_NAME',
    OrganizationName: 'ORGANIZATION_NAME',
    EmployeeIdentificationNumber: 'EMPLOYEE_IDENTIFICATION_NUMBER'
} as const;

export type AdminChallengeB2bFormSchemaAvailableFieldNameEnumDTO = typeof AdminChallengeB2bFormSchemaAvailableFieldNameEnumDTO[keyof typeof AdminChallengeB2bFormSchemaAvailableFieldNameEnumDTO];


/**
 * 
 * @export
 * @interface AdminChallengeB2bFormSchemaDTO
 */
export interface AdminChallengeB2bFormSchemaDTO {
    /**
     * 
     * @type {Array<AdminChallengeB2bFormSchemaAvailableFieldDTO>}
     * @memberof AdminChallengeB2bFormSchemaDTO
     */
    'availableFields': Array<AdminChallengeB2bFormSchemaAvailableFieldDTO>;
}
/**
 * 
 * @export
 * @interface AdminChallengeConditionDTO
 */
export interface AdminChallengeConditionDTO {
    /**
     * 
     * @type {AdminChallengeAddressConditionDTO}
     * @memberof AdminChallengeConditionDTO
     */
    'addressCondition'?: AdminChallengeAddressConditionDTO;
    /**
     * 
     * @type {AdminChallengeActionConditionDTO}
     * @memberof AdminChallengeConditionDTO
     */
    'actionCondition'?: AdminChallengeActionConditionDTO;
}
/**
 * 
 * @export
 * @interface AdminChallengeDTO
 */
export interface AdminChallengeDTO {
    /**
     * 
     * @type {string}
     * @memberof AdminChallengeDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AdminChallengeDTO
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof AdminChallengeDTO
     */
    'isPublic': boolean;
    /**
     * 
     * @type {string}
     * @memberof AdminChallengeDTO
     */
    'invitationCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminChallengeDTO
     */
    'passcode'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AdminChallengeDTO
     */
    'isComplete': boolean;
    /**
     * 
     * @type {number}
     * @memberof AdminChallengeDTO
     */
    'startsAtMillis': number;
    /**
     * 
     * @type {number}
     * @memberof AdminChallengeDTO
     */
    'endsAtMillis'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminChallengeDTO
     */
    'joinStartAtMillis'?: number;
    /**
     * 
     * @type {string}
     * @memberof AdminChallengeDTO
     */
    'b2bGroupId'?: string;
    /**
     * 
     * @type {number}
     * @memberof AdminChallengeDTO
     */
    'goal': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof AdminChallengeDTO
     */
    'milestones': Array<number>;
    /**
     * 
     * @type {Array<AdminChallengeConditionDTO>}
     * @memberof AdminChallengeDTO
     */
    'conditions': Array<AdminChallengeConditionDTO>;
    /**
     * 
     * @type {number}
     * @memberof AdminChallengeDTO
     */
    'createdAtMillis': number;
    /**
     * 
     * @type {number}
     * @memberof AdminChallengeDTO
     */
    'updatedAtMillis': number;
    /**
     * 
     * @type {string}
     * @memberof AdminChallengeDTO
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof AdminChallengeDTO
     */
    'isB2B'?: boolean;
    /**
     * 
     * @type {AdminChallengeB2bFormSchemaDTO}
     * @memberof AdminChallengeDTO
     */
    'b2bFormSchema'?: AdminChallengeB2bFormSchemaDTO;
    /**
     * 
     * @type {AdminCrusherGroupDto}
     * @memberof AdminChallengeDTO
     */
    'crusherGroup'?: AdminCrusherGroupDto;
    /**
     * 
     * @type {ChallengeAggregationPeriodTypeEnum}
     * @memberof AdminChallengeDTO
     */
    'aggregationPeriodType'?: ChallengeAggregationPeriodTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AdminChallengeDTO
     */
    'lastMonthRankImageUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminChallengeDTO
     */
    'modalImageUrl'?: string;
    /**
     * When enabled, past contributions within challenge period are applied on join
     * @type {boolean}
     * @memberof AdminChallengeDTO
     */
    'isRetroactiveContributionEnabled'?: boolean;
}
/**
 * 원형 검색 영역
 * @export
 * @interface AdminCircleSearchRegionDto
 */
export interface AdminCircleSearchRegionDto {
    /**
     * 
     * @type {LocationDTO}
     * @memberof AdminCircleSearchRegionDto
     */
    'centerLocation': LocationDTO;
    /**
     * 
     * @type {number}
     * @memberof AdminCircleSearchRegionDto
     */
    'radiusMeters': number;
}
/**
 * 
 * @export
 * @interface AdminClosedPlaceCandidateDTO
 */
export interface AdminClosedPlaceCandidateDTO {
    /**
     * 
     * @type {string}
     * @memberof AdminClosedPlaceCandidateDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AdminClosedPlaceCandidateDTO
     */
    'placeId': string;
    /**
     * 
     * @type {string}
     * @memberof AdminClosedPlaceCandidateDTO
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminClosedPlaceCandidateDTO
     */
    'address'?: string;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminClosedPlaceCandidateDTO
     */
    'closedAt'?: EpochMillisTimestamp;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminClosedPlaceCandidateDTO
     */
    'acceptedAt'?: EpochMillisTimestamp;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminClosedPlaceCandidateDTO
     */
    'ignoredAt'?: EpochMillisTimestamp;
}
/**
 * 
 * @export
 * @interface AdminCreateBannerRequestDTO
 */
export interface AdminCreateBannerRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof AdminCreateBannerRequestDTO
     */
    'loggingKey': string;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateBannerRequestDTO
     */
    'imageUrl': string;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateBannerRequestDTO
     */
    'clickPageUrl': string;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateBannerRequestDTO
     */
    'clickPageTitle': string;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminCreateBannerRequestDTO
     */
    'startAt'?: EpochMillisTimestamp;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminCreateBannerRequestDTO
     */
    'endAt'?: EpochMillisTimestamp;
    /**
     * 
     * @type {number}
     * @memberof AdminCreateBannerRequestDTO
     */
    'displayOrder': number;
    /**
     * 
     * @type {HomeBannerTypeDTO}
     * @memberof AdminCreateBannerRequestDTO
     */
    'bannerType': HomeBannerTypeDTO;
}
/**
 * Building Division 생성 요청
 * @export
 * @interface AdminCreateBuildingDivisionRequestDTO
 */
export interface AdminCreateBuildingDivisionRequestDTO {
    /**
     * 충돌이 발생한 Building ID
     * @type {string}
     * @memberof AdminCreateBuildingDivisionRequestDTO
     */
    'buildingId': string;
    /**
     * 분할 사유
     * @type {string}
     * @memberof AdminCreateBuildingDivisionRequestDTO
     */
    'divisionReason'?: string;
}
/**
 * 
 * @export
 * @interface AdminCreateChallengeRequestDTO
 */
export interface AdminCreateChallengeRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof AdminCreateChallengeRequestDTO
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof AdminCreateChallengeRequestDTO
     */
    'isPublic': boolean;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateChallengeRequestDTO
     */
    'invitationCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateChallengeRequestDTO
     */
    'passcode'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateChallengeRequestDTO
     */
    'companyName'?: string;
    /**
     * 
     * @type {number}
     * @memberof AdminCreateChallengeRequestDTO
     */
    'startsAtMillis': number;
    /**
     * 
     * @type {number}
     * @memberof AdminCreateChallengeRequestDTO
     */
    'endsAtMillis'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminCreateChallengeRequestDTO
     */
    'joinStartAtMillis'?: number;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateChallengeRequestDTO
     */
    'b2bGroupId'?: string;
    /**
     * 
     * @type {number}
     * @memberof AdminCreateChallengeRequestDTO
     */
    'goal': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof AdminCreateChallengeRequestDTO
     */
    'milestones': Array<number>;
    /**
     * 
     * @type {Array<AdminChallengeConditionDTO>}
     * @memberof AdminCreateChallengeRequestDTO
     */
    'conditions': Array<AdminChallengeConditionDTO>;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateChallengeRequestDTO
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof AdminCreateChallengeRequestDTO
     */
    'isB2B'?: boolean;
    /**
     * 
     * @type {AdminChallengeB2bFormSchemaDTO}
     * @memberof AdminCreateChallengeRequestDTO
     */
    'b2bFormSchema'?: AdminChallengeB2bFormSchemaDTO;
    /**
     * 
     * @type {AdminCrusherGroupDto}
     * @memberof AdminCreateChallengeRequestDTO
     */
    'crusherGroup'?: AdminCrusherGroupDto;
    /**
     * 
     * @type {ChallengeAggregationPeriodTypeEnum}
     * @memberof AdminCreateChallengeRequestDTO
     */
    'aggregationPeriodType'?: ChallengeAggregationPeriodTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateChallengeRequestDTO
     */
    'lastMonthRankImageUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateChallengeRequestDTO
     */
    'modalImageUrl'?: string;
    /**
     * When enabled, past contributions within challenge period are applied on join
     * @type {boolean}
     * @memberof AdminCreateChallengeRequestDTO
     */
    'isRetroactiveContributionEnabled'?: boolean;
}
/**
 * 
 * @export
 * @interface AdminCreateHomeAnnouncementRequestDTO
 */
export interface AdminCreateHomeAnnouncementRequestDTO {
    /**
     * 공지사항 텍스트
     * @type {string}
     * @memberof AdminCreateHomeAnnouncementRequestDTO
     */
    'text': string;
    /**
     * 클릭 시 이동할 URL
     * @type {string}
     * @memberof AdminCreateHomeAnnouncementRequestDTO
     */
    'linkUrl': string;
    /**
     * 
     * @type {number}
     * @memberof AdminCreateHomeAnnouncementRequestDTO
     */
    'displayOrder': number;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminCreateHomeAnnouncementRequestDTO
     */
    'startAt'?: EpochMillisTimestamp;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminCreateHomeAnnouncementRequestDTO
     */
    'endAt'?: EpochMillisTimestamp;
}
/**
 * 
 * @export
 * @interface AdminCreateHomeRecommendedContentRequestDTO
 */
export interface AdminCreateHomeRecommendedContentRequestDTO {
    /**
     * 컨텐츠 제목
     * @type {string}
     * @memberof AdminCreateHomeRecommendedContentRequestDTO
     */
    'title': string;
    /**
     * 컨텐츠 설명
     * @type {string}
     * @memberof AdminCreateHomeRecommendedContentRequestDTO
     */
    'description': string;
    /**
     * 컨텐츠 이미지 URL
     * @type {string}
     * @memberof AdminCreateHomeRecommendedContentRequestDTO
     */
    'imageUrl': string;
    /**
     * 클릭 시 이동할 URL (딥링크 가능)
     * @type {string}
     * @memberof AdminCreateHomeRecommendedContentRequestDTO
     */
    'linkUrl': string;
    /**
     * 
     * @type {number}
     * @memberof AdminCreateHomeRecommendedContentRequestDTO
     */
    'displayOrder': number;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminCreateHomeRecommendedContentRequestDTO
     */
    'startAt'?: EpochMillisTimestamp;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminCreateHomeRecommendedContentRequestDTO
     */
    'endAt'?: EpochMillisTimestamp;
}
/**
 * 
 * @export
 * @interface AdminCreateImageUploadUrlsRequestDTO
 */
export interface AdminCreateImageUploadUrlsRequestDTO {
    /**
     * 
     * @type {AdminImageUploadPurposeTypeDTO}
     * @memberof AdminCreateImageUploadUrlsRequestDTO
     */
    'purposeType': AdminImageUploadPurposeTypeDTO;
    /**
     * 업로드할 이미지 수.
     * @type {number}
     * @memberof AdminCreateImageUploadUrlsRequestDTO
     */
    'count': number;
    /**
     * 업로드할 이미지의 확장자. \'.\'을 붙이지 말아야 한다. e.g. png, jpeg 등.
     * @type {string}
     * @memberof AdminCreateImageUploadUrlsRequestDTO
     */
    'filenameExtension': string;
}
/**
 * 
 * @export
 * @interface AdminCreateImageUploadUrlsResponseDTO
 */
export interface AdminCreateImageUploadUrlsResponseDTO {
    /**
     * 
     * @type {Array<AdminImageUploadUrlDTO>}
     * @memberof AdminCreateImageUploadUrlsResponseDTO
     */
    'urls': Array<AdminImageUploadUrlDTO>;
}
/**
 * 장소 카테고리 캐시 생성 요청
 * @export
 * @interface AdminCreatePlaceCategoryCacheRequestDto
 */
export interface AdminCreatePlaceCategoryCacheRequestDto {
    /**
     * 지도 API에서 반환된 원본 카테고리 문자열
     * @type {string}
     * @memberof AdminCreatePlaceCategoryCacheRequestDto
     */
    'categoryString': string;
    /**
     * 
     * @type {PlaceCategoryDto}
     * @memberof AdminCreatePlaceCategoryCacheRequestDto
     */
    'placeCategory': PlaceCategoryDto;
}
/**
 * 저장 리스트 생성 요청
 * @export
 * @interface AdminCreatePlaceListRequestDto
 */
export interface AdminCreatePlaceListRequestDto {
    /**
     * 
     * @type {string}
     * @memberof AdminCreatePlaceListRequestDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AdminCreatePlaceListRequestDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AdminCreatePlaceListRequestDto
     */
    'thumbnailUrl'?: string | null;
    /**
     * 아이콘 배경색 (hex, e.g. \"#FFC01E\"). null이면 기본색 사용.
     * @type {string}
     * @memberof AdminCreatePlaceListRequestDto
     */
    'iconColor'?: string | null;
    /**
     * 리스트에 포함할 장소 ID 목록
     * @type {Array<string>}
     * @memberof AdminCreatePlaceListRequestDto
     */
    'placeIds': Array<string>;
}
/**
 * 
 * @export
 * @interface AdminCreateSearchPlacePresetRequestDTO
 */
export interface AdminCreateSearchPlacePresetRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof AdminCreateSearchPlacePresetRequestDTO
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateSearchPlacePresetRequestDTO
     */
    'searchText': string;
}
/**
 * SubBuilding 생성 요청
 * @export
 * @interface AdminCreateSubBuildingRequestDTO
 */
export interface AdminCreateSubBuildingRequestDTO {
    /**
     * 서브 건물 이름
     * @type {string}
     * @memberof AdminCreateSubBuildingRequestDTO
     */
    'subBuildingName': string;
    /**
     * 서브 건물 중심 경도
     * @type {number}
     * @memberof AdminCreateSubBuildingRequestDTO
     */
    'centerLng': number;
    /**
     * 서브 건물 중심 위도
     * @type {number}
     * @memberof AdminCreateSubBuildingRequestDTO
     */
    'centerLat': number;
    /**
     * 서브 건물 경계 (WKT Polygon 형식) 예: POLYGON((127.001 37.001, 127.002 37.001, 127.002 37.002, 127.001 37.002, 127.001 37.001)) 
     * @type {string}
     * @memberof AdminCreateSubBuildingRequestDTO
     */
    'boundaryWkt': string;
    /**
     * 메모
     * @type {string}
     * @memberof AdminCreateSubBuildingRequestDTO
     */
    'notes'?: string;
}
/**
 * 
 * @export
 * @interface AdminCrusherGroupDto
 */
export interface AdminCrusherGroupDto {
    /**
     * 
     * @type {string}
     * @memberof AdminCrusherGroupDto
     */
    'name': string;
    /**
     * 
     * @type {AdminCrusherGroupDtoIcon}
     * @memberof AdminCrusherGroupDto
     */
    'icon'?: AdminCrusherGroupDtoIcon;
}
/**
 * 
 * @export
 * @interface AdminCrusherGroupDtoIcon
 */
export interface AdminCrusherGroupDtoIcon {
    /**
     * 
     * @type {string}
     * @memberof AdminCrusherGroupDtoIcon
     */
    'url': string;
    /**
     * 
     * @type {number}
     * @memberof AdminCrusherGroupDtoIcon
     */
    'width': number;
    /**
     * 
     * @type {number}
     * @memberof AdminCrusherGroupDtoIcon
     */
    'height': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AdminEntranceDoorType = {
    None: 'None',
    Hinged: 'Hinged',
    Sliding: 'Sliding',
    Revolving: 'Revolving',
    Automatic: 'Automatic',
    Etc: 'ETC'
} as const;

export type AdminEntranceDoorType = typeof AdminEntranceDoorType[keyof typeof AdminEntranceDoorType];


/**
 * 
 * @export
 * @interface AdminHomeAnnouncementDTO
 */
export interface AdminHomeAnnouncementDTO {
    /**
     * 
     * @type {string}
     * @memberof AdminHomeAnnouncementDTO
     */
    'id': string;
    /**
     * 공지사항 텍스트
     * @type {string}
     * @memberof AdminHomeAnnouncementDTO
     */
    'text': string;
    /**
     * 클릭 시 이동할 URL
     * @type {string}
     * @memberof AdminHomeAnnouncementDTO
     */
    'linkUrl': string;
    /**
     * 
     * @type {number}
     * @memberof AdminHomeAnnouncementDTO
     */
    'displayOrder': number;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminHomeAnnouncementDTO
     */
    'startAt'?: EpochMillisTimestamp;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminHomeAnnouncementDTO
     */
    'endAt'?: EpochMillisTimestamp;
}
/**
 * 
 * @export
 * @interface AdminHomeRecommendedContentDTO
 */
export interface AdminHomeRecommendedContentDTO {
    /**
     * 
     * @type {string}
     * @memberof AdminHomeRecommendedContentDTO
     */
    'id': string;
    /**
     * 컨텐츠 제목
     * @type {string}
     * @memberof AdminHomeRecommendedContentDTO
     */
    'title': string;
    /**
     * 컨텐츠 설명
     * @type {string}
     * @memberof AdminHomeRecommendedContentDTO
     */
    'description': string;
    /**
     * 컨텐츠 이미지 URL
     * @type {string}
     * @memberof AdminHomeRecommendedContentDTO
     */
    'imageUrl': string;
    /**
     * 클릭 시 이동할 URL (딥링크 가능)
     * @type {string}
     * @memberof AdminHomeRecommendedContentDTO
     */
    'linkUrl': string;
    /**
     * 
     * @type {number}
     * @memberof AdminHomeRecommendedContentDTO
     */
    'displayOrder': number;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminHomeRecommendedContentDTO
     */
    'startAt'?: EpochMillisTimestamp;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminHomeRecommendedContentDTO
     */
    'endAt'?: EpochMillisTimestamp;
}
/**
 * 
 * @export
 * @interface AdminImageDTO
 */
export interface AdminImageDTO {
    /**
     * 
     * @type {string}
     * @memberof AdminImageDTO
     */
    'imageUrl': string;
    /**
     * 
     * @type {string}
     * @memberof AdminImageDTO
     */
    'thumbnailUrl'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AdminImageUploadPurposeTypeDTO = {
    Banner: 'BANNER',
    CrusherLabel: 'CRUSHER_LABEL',
    BbucleRoadMarker: 'BBUCLE_ROAD_MARKER',
    BbucleRoadDescription: 'BBUCLE_ROAD_DESCRIPTION',
    RecommendedContent: 'RECOMMENDED_CONTENT'
} as const;

export type AdminImageUploadPurposeTypeDTO = typeof AdminImageUploadPurposeTypeDTO[keyof typeof AdminImageUploadPurposeTypeDTO];


/**
 * 
 * @export
 * @interface AdminImageUploadUrlDTO
 */
export interface AdminImageUploadUrlDTO {
    /**
     * 
     * @type {string}
     * @memberof AdminImageUploadUrlDTO
     */
    'url': string;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminImageUploadUrlDTO
     */
    'expireAt': EpochMillisTimestamp;
}
/**
 * 
 * @export
 * @interface AdminListAllBannersResponseDTO
 */
export interface AdminListAllBannersResponseDTO {
    /**
     * 
     * @type {Array<AdminBannerDTO>}
     * @memberof AdminListAllBannersResponseDTO
     */
    'banners': Array<AdminBannerDTO>;
}
/**
 * 
 * @export
 * @interface AdminListBuildingDeduplicationCandidatesResponseDTO
 */
export interface AdminListBuildingDeduplicationCandidatesResponseDTO {
    /**
     * 
     * @type {Array<AdminBuildingDeduplicationCandidateDTO>}
     * @memberof AdminListBuildingDeduplicationCandidatesResponseDTO
     */
    'items': Array<AdminBuildingDeduplicationCandidateDTO>;
    /**
     * 없으면 다음 페이지가 없다는 의미.
     * @type {string}
     * @memberof AdminListBuildingDeduplicationCandidatesResponseDTO
     */
    'cursor'?: string;
}
/**
 * Building Division 목록 조회 응답
 * @export
 * @interface AdminListBuildingDivisionsResponseDTO
 */
export interface AdminListBuildingDivisionsResponseDTO {
    /**
     * Building Division 목록
     * @type {Array<AdminBuildingDivisionDTO>}
     * @memberof AdminListBuildingDivisionsResponseDTO
     */
    'items': Array<AdminBuildingDivisionDTO>;
    /**
     * 없으면 다음 페이지가 없다는 의미.
     * @type {string}
     * @memberof AdminListBuildingDivisionsResponseDTO
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface AdminListClosedPlaceCandidatesResponseDTO
 */
export interface AdminListClosedPlaceCandidatesResponseDTO {
    /**
     * 
     * @type {Array<AdminClosedPlaceCandidateDTO>}
     * @memberof AdminListClosedPlaceCandidatesResponseDTO
     */
    'items'?: Array<AdminClosedPlaceCandidateDTO>;
    /**
     * 없으면 다음 페이지가 없다는 의미.
     * @type {string}
     * @memberof AdminListClosedPlaceCandidatesResponseDTO
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface AdminListHomeAnnouncementsResponseDTO
 */
export interface AdminListHomeAnnouncementsResponseDTO {
    /**
     * 
     * @type {Array<AdminHomeAnnouncementDTO>}
     * @memberof AdminListHomeAnnouncementsResponseDTO
     */
    'announcements': Array<AdminHomeAnnouncementDTO>;
}
/**
 * 
 * @export
 * @interface AdminListHomeBannersResponseDTO
 */
export interface AdminListHomeBannersResponseDTO {
    /**
     * 
     * @type {Array<AdminBannerDTO>}
     * @memberof AdminListHomeBannersResponseDTO
     */
    'banners': Array<AdminBannerDTO>;
}
/**
 * 
 * @export
 * @interface AdminListHomeRecommendedContentsResponseDTO
 */
export interface AdminListHomeRecommendedContentsResponseDTO {
    /**
     * 
     * @type {Array<AdminHomeRecommendedContentDTO>}
     * @memberof AdminListHomeRecommendedContentsResponseDTO
     */
    'contents': Array<AdminHomeRecommendedContentDTO>;
}
/**
 * 장소 카테고리 캐시 목록 응답
 * @export
 * @interface AdminListPlaceCategoryCachesResponseDto
 */
export interface AdminListPlaceCategoryCachesResponseDto {
    /**
     * 
     * @type {Array<AdminPlaceCategoryCacheDto>}
     * @memberof AdminListPlaceCategoryCachesResponseDto
     */
    'items': Array<AdminPlaceCategoryCacheDto>;
    /**
     * 다음 페이지 커서 (없으면 마지막 페이지)
     * @type {string}
     * @memberof AdminListPlaceCategoryCachesResponseDto
     */
    'cursor'?: string | null;
}
/**
 * 저장 리스트 목록 응답
 * @export
 * @interface AdminListPlaceListsResponseDto
 */
export interface AdminListPlaceListsResponseDto {
    /**
     * 
     * @type {Array<AdminPlaceListDto>}
     * @memberof AdminListPlaceListsResponseDto
     */
    'items': Array<AdminPlaceListDto>;
    /**
     * 다음 페이지 커서 (없으면 마지막 페이지)
     * @type {string}
     * @memberof AdminListPlaceListsResponseDto
     */
    'cursor'?: string | null;
}
/**
 * 
 * @export
 * @interface AdminListPushNotificationSchedulesResponseDTO
 */
export interface AdminListPushNotificationSchedulesResponseDTO {
    /**
     * 
     * @type {Array<AdminPushNotificationScheduleDTO>}
     * @memberof AdminListPushNotificationSchedulesResponseDTO
     */
    'list': Array<AdminPushNotificationScheduleDTO>;
    /**
     * 없으면 다음 페이지가 없다는 의미.
     * @type {string}
     * @memberof AdminListPushNotificationSchedulesResponseDTO
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface AdminPlaceAccessibilityDTO
 */
export interface AdminPlaceAccessibilityDTO {
    /**
     * 
     * @type {string}
     * @memberof AdminPlaceAccessibilityDTO
     */
    'id': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof AdminPlaceAccessibilityDTO
     */
    'floors'?: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof AdminPlaceAccessibilityDTO
     */
    'isFirstFloor': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AdminPlaceAccessibilityDTO
     */
    'isStairOnlyOption'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof AdminPlaceAccessibilityDTO
     * @deprecated
     */
    'imageUrls': Array<string>;
    /**
     * 
     * @type {Array<AdminImageDTO>}
     * @memberof AdminPlaceAccessibilityDTO
     */
    'images': Array<AdminImageDTO>;
    /**
     * 
     * @type {AdminStairInfoDTO}
     * @memberof AdminPlaceAccessibilityDTO
     */
    'stairInfo': AdminStairInfoDTO;
    /**
     * 
     * @type {AdminStairHeightLevel}
     * @memberof AdminPlaceAccessibilityDTO
     */
    'stairHeightLevel'?: AdminStairHeightLevel;
    /**
     * 
     * @type {boolean}
     * @memberof AdminPlaceAccessibilityDTO
     */
    'hasSlope': boolean;
    /**
     * 
     * @type {Array<AdminEntranceDoorType>}
     * @memberof AdminPlaceAccessibilityDTO
     */
    'entranceDoorTypes'?: Array<AdminEntranceDoorType>;
    /**
     * 
     * @type {string}
     * @memberof AdminPlaceAccessibilityDTO
     */
    'placeName': string;
    /**
     * 익명으로 등록되었으면 null.
     * @type {string}
     * @memberof AdminPlaceAccessibilityDTO
     */
    'registeredUserName'?: string;
    /**
     * 
     * @type {number}
     * @memberof AdminPlaceAccessibilityDTO
     */
    'createdAtMillis': number;
}
/**
 * 장소 카테고리 캐시 정보
 * @export
 * @interface AdminPlaceCategoryCacheDto
 */
export interface AdminPlaceCategoryCacheDto {
    /**
     * 
     * @type {string}
     * @memberof AdminPlaceCategoryCacheDto
     */
    'id': string;
    /**
     * 지도 API에서 반환된 원본 카테고리 문자열
     * @type {string}
     * @memberof AdminPlaceCategoryCacheDto
     */
    'categoryString': string;
    /**
     * 
     * @type {PlaceCategoryDto}
     * @memberof AdminPlaceCategoryCacheDto
     */
    'placeCategory': PlaceCategoryDto;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminPlaceCategoryCacheDto
     */
    'createdAt': EpochMillisTimestamp;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminPlaceCategoryCacheDto
     */
    'updatedAt': EpochMillisTimestamp;
}
/**
 * 저장 리스트 상세 정보 (장소 목록 포함)
 * @export
 * @interface AdminPlaceListDetailDto
 */
export interface AdminPlaceListDetailDto {
    /**
     * 
     * @type {string}
     * @memberof AdminPlaceListDetailDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AdminPlaceListDetailDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AdminPlaceListDetailDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AdminPlaceListDetailDto
     */
    'thumbnailUrl'?: string | null;
    /**
     * 아이콘 배경색 (hex, e.g. \"#FFC01E\"). null이면 기본색 사용.
     * @type {string}
     * @memberof AdminPlaceListDetailDto
     */
    'iconColor'?: string | null;
    /**
     * 
     * @type {Array<AdminPlaceListPlaceDto>}
     * @memberof AdminPlaceListDetailDto
     */
    'places': Array<AdminPlaceListPlaceDto>;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminPlaceListDetailDto
     */
    'createdAt': EpochMillisTimestamp;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminPlaceListDetailDto
     */
    'updatedAt': EpochMillisTimestamp;
}
/**
 * 저장 리스트 목록 항목
 * @export
 * @interface AdminPlaceListDto
 */
export interface AdminPlaceListDto {
    /**
     * 
     * @type {string}
     * @memberof AdminPlaceListDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AdminPlaceListDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AdminPlaceListDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AdminPlaceListDto
     */
    'thumbnailUrl'?: string | null;
    /**
     * 아이콘 배경색 (hex, e.g. \"#FFC01E\"). null이면 기본색 사용.
     * @type {string}
     * @memberof AdminPlaceListDto
     */
    'iconColor'?: string | null;
    /**
     * 리스트에 포함된 장소 수
     * @type {number}
     * @memberof AdminPlaceListDto
     */
    'placeCount': number;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminPlaceListDto
     */
    'createdAt': EpochMillisTimestamp;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminPlaceListDto
     */
    'updatedAt': EpochMillisTimestamp;
}
/**
 * 저장 리스트에 포함된 장소 정보
 * @export
 * @interface AdminPlaceListPlaceDto
 */
export interface AdminPlaceListPlaceDto {
    /**
     * 
     * @type {string}
     * @memberof AdminPlaceListPlaceDto
     */
    'placeId': string;
    /**
     * 
     * @type {string}
     * @memberof AdminPlaceListPlaceDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AdminPlaceListPlaceDto
     */
    'address'?: string | null;
    /**
     * 
     * @type {LocationDTO}
     * @memberof AdminPlaceListPlaceDto
     */
    'location': LocationDTO;
    /**
     * 
     * @type {number}
     * @memberof AdminPlaceListPlaceDto
     */
    'accessibilityScore'?: number | null;
}
/**
 * 
 * @export
 * @interface AdminPushNotificationScheduleDTO
 */
export interface AdminPushNotificationScheduleDTO {
    /**
     * 
     * @type {string}
     * @memberof AdminPushNotificationScheduleDTO
     */
    'id': string;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminPushNotificationScheduleDTO
     */
    'scheduledAt'?: EpochMillisTimestamp;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminPushNotificationScheduleDTO
     */
    'sentAt'?: EpochMillisTimestamp;
    /**
     * 
     * @type {string}
     * @memberof AdminPushNotificationScheduleDTO
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminPushNotificationScheduleDTO
     */
    'body': string;
    /**
     * 
     * @type {string}
     * @memberof AdminPushNotificationScheduleDTO
     */
    'deepLink'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AdminPushNotificationScheduleDTO
     */
    'targetUserIds': Array<string>;
}
/**
 * 직사각형 검색 영역
 * @export
 * @interface AdminRectangleSearchRegionDto
 */
export interface AdminRectangleSearchRegionDto {
    /**
     * 
     * @type {LocationDTO}
     * @memberof AdminRectangleSearchRegionDto
     */
    'leftTopLocation': LocationDTO;
    /**
     * 
     * @type {LocationDTO}
     * @memberof AdminRectangleSearchRegionDto
     */
    'rightBottomLocation': LocationDTO;
}
/**
 * 
 * @export
 * @interface AdminSearchAccessibilitiesResultDTO
 */
export interface AdminSearchAccessibilitiesResultDTO {
    /**
     * 
     * @type {Array<AdminAccessibilityDTO>}
     * @memberof AdminSearchAccessibilitiesResultDTO
     */
    'items': Array<AdminAccessibilityDTO>;
    /**
     * 없으면 다음 페이지가 없다는 의미.
     * @type {string}
     * @memberof AdminSearchAccessibilitiesResultDTO
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface AdminSearchAccessibilityInspectionResultsDTO
 */
export interface AdminSearchAccessibilityInspectionResultsDTO {
    /**
     * 
     * @type {Array<AdminAccessibilityInspectionResultDTO>}
     * @memberof AdminSearchAccessibilityInspectionResultsDTO
     */
    'items': Array<AdminAccessibilityInspectionResultDTO>;
    /**
     * 없으면 다음 페이지가 없다는 의미.
     * @type {string}
     * @memberof AdminSearchAccessibilityInspectionResultsDTO
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface AdminSearchPlacePresetDTO
 */
export interface AdminSearchPlacePresetDTO {
    /**
     * 
     * @type {string}
     * @memberof AdminSearchPlacePresetDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AdminSearchPlacePresetDTO
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof AdminSearchPlacePresetDTO
     */
    'searchText': string;
}
/**
 * 키워드 장소 검색 요청
 * @export
 * @interface AdminSearchPlacesByKeywordRequestDto
 */
export interface AdminSearchPlacesByKeywordRequestDto {
    /**
     * 
     * @type {string}
     * @memberof AdminSearchPlacesByKeywordRequestDto
     */
    'keyword': string;
    /**
     * 
     * @type {AdminCircleSearchRegionDto}
     * @memberof AdminSearchPlacesByKeywordRequestDto
     */
    'circleRegion'?: AdminCircleSearchRegionDto;
    /**
     * 
     * @type {AdminRectangleSearchRegionDto}
     * @memberof AdminSearchPlacesByKeywordRequestDto
     */
    'rectangleRegion'?: AdminRectangleSearchRegionDto;
}
/**
 * 키워드 장소 검색 응답
 * @export
 * @interface AdminSearchPlacesByKeywordResponseDto
 */
export interface AdminSearchPlacesByKeywordResponseDto {
    /**
     * 
     * @type {Array<AdminSearchedPlaceDto>}
     * @memberof AdminSearchPlacesByKeywordResponseDto
     */
    'items': Array<AdminSearchedPlaceDto>;
}
/**
 * 검색된 장소 정보
 * @export
 * @interface AdminSearchedPlaceDto
 */
export interface AdminSearchedPlaceDto {
    /**
     * 
     * @type {string}
     * @memberof AdminSearchedPlaceDto
     */
    'placeId': string;
    /**
     * 
     * @type {string}
     * @memberof AdminSearchedPlaceDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AdminSearchedPlaceDto
     */
    'address'?: string | null;
    /**
     * 
     * @type {LocationDTO}
     * @memberof AdminSearchedPlaceDto
     */
    'location': LocationDTO;
    /**
     * 
     * @type {boolean}
     * @memberof AdminSearchedPlaceDto
     */
    'hasBuildingAccessibility': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AdminSearchedPlaceDto
     */
    'hasPlaceAccessibility': boolean;
    /**
     * 
     * @type {number}
     * @memberof AdminSearchedPlaceDto
     */
    'accessibilityScore'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof AdminSearchedPlaceDto
     */
    'isAccessibilityRegistrable': boolean;
}
/**
 * 
 * @export
 * @interface AdminSendPushNotificationRequestDTO
 */
export interface AdminSendPushNotificationRequestDTO {
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminSendPushNotificationRequestDTO
     */
    'scheduledAt'?: EpochMillisTimestamp;
    /**
     * 
     * @type {Array<string>}
     * @memberof AdminSendPushNotificationRequestDTO
     */
    'userIds': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AdminSendPushNotificationRequestDTO
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminSendPushNotificationRequestDTO
     */
    'body': string;
    /**
     * 
     * @type {string}
     * @memberof AdminSendPushNotificationRequestDTO
     */
    'deepLink'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AdminStairHeightLevel = {
    HalfThumb: 'HALF_THUMB',
    Thumb: 'THUMB',
    OverThumb: 'OVER_THUMB'
} as const;

export type AdminStairHeightLevel = typeof AdminStairHeightLevel[keyof typeof AdminStairHeightLevel];


/**
 * 
 * @export
 * @enum {string}
 */

export const AdminStairInfoDTO = {
    Undefined: 'UNDEFINED',
    None: 'NONE',
    One: 'ONE',
    TwoToFive: 'TWO_TO_FIVE',
    OverSix: 'OVER_SIX'
} as const;

export type AdminStairInfoDTO = typeof AdminStairInfoDTO[keyof typeof AdminStairInfoDTO];


/**
 * SubBuilding 정보
 * @export
 * @interface AdminSubBuildingDTO
 */
export interface AdminSubBuildingDTO {
    /**
     * SubBuilding ID
     * @type {string}
     * @memberof AdminSubBuildingDTO
     */
    'id': string;
    /**
     * 소속된 Building Division ID
     * @type {string}
     * @memberof AdminSubBuildingDTO
     */
    'buildingDivisionId': string;
    /**
     * 서브 건물 이름 예: 연세대학교 신촌캠퍼스 대강당, 연세대학교 신촌캠퍼스 백양관 
     * @type {string}
     * @memberof AdminSubBuildingDTO
     */
    'subBuildingName': string;
    /**
     * 
     * @type {LocationDTO}
     * @memberof AdminSubBuildingDTO
     */
    'centerLocation': LocationDTO;
    /**
     * 서브 건물 경계 (WKT Polygon 형식) 예: POLYGON((127.001 37.001, 127.002 37.001, 127.002 37.002, 127.001 37.002, 127.001 37.001)) 
     * @type {string}
     * @memberof AdminSubBuildingDTO
     */
    'boundaryWkt': string;
    /**
     * 메모
     * @type {string}
     * @memberof AdminSubBuildingDTO
     */
    'notes'?: string;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminSubBuildingDTO
     */
    'confirmedAt'?: EpochMillisTimestamp;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminSubBuildingDTO
     */
    'createdAt': EpochMillisTimestamp;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminSubBuildingDTO
     */
    'updatedAt': EpochMillisTimestamp;
}
/**
 * 
 * @export
 * @interface AdminUpdateBuildingAccessibilityRequestDTO
 */
export interface AdminUpdateBuildingAccessibilityRequestDTO {
    /**
     * 
     * @type {AdminStairInfoDTO}
     * @memberof AdminUpdateBuildingAccessibilityRequestDTO
     */
    'entranceStairInfo': AdminStairInfoDTO;
    /**
     * 
     * @type {boolean}
     * @memberof AdminUpdateBuildingAccessibilityRequestDTO
     */
    'hasSlope': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AdminUpdateBuildingAccessibilityRequestDTO
     */
    'hasElevator': boolean;
    /**
     * 
     * @type {AdminStairInfoDTO}
     * @memberof AdminUpdateBuildingAccessibilityRequestDTO
     */
    'elevatorStairInfo': AdminStairInfoDTO;
    /**
     * 
     * @type {AdminStairHeightLevel}
     * @memberof AdminUpdateBuildingAccessibilityRequestDTO
     */
    'entranceStairHeightLevel'?: AdminStairHeightLevel;
    /**
     * 
     * @type {Array<AdminEntranceDoorType>}
     * @memberof AdminUpdateBuildingAccessibilityRequestDTO
     */
    'entranceDoorTypes'?: Array<AdminEntranceDoorType>;
    /**
     * 
     * @type {AdminStairHeightLevel}
     * @memberof AdminUpdateBuildingAccessibilityRequestDTO
     */
    'elevatorStairHeightLevel'?: AdminStairHeightLevel;
}
/**
 * 
 * @export
 * @interface AdminUpdateChallengeRequestDTO
 */
export interface AdminUpdateChallengeRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateChallengeRequestDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateChallengeRequestDTO
     */
    'invitationCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateChallengeRequestDTO
     */
    'passcode'?: string;
    /**
     * 
     * @type {number}
     * @memberof AdminUpdateChallengeRequestDTO
     */
    'startsAtMillis'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminUpdateChallengeRequestDTO
     */
    'endsAtMillis'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminUpdateChallengeRequestDTO
     */
    'joinStartAtMillis'?: number;
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateChallengeRequestDTO
     */
    'b2bGroupId'?: string;
    /**
     * 
     * @type {number}
     * @memberof AdminUpdateChallengeRequestDTO
     */
    'goal'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof AdminUpdateChallengeRequestDTO
     */
    'milestones'?: Array<number>;
    /**
     * 
     * @type {Array<AdminChallengeConditionDTO>}
     * @memberof AdminUpdateChallengeRequestDTO
     */
    'conditions'?: Array<AdminChallengeConditionDTO>;
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateChallengeRequestDTO
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof AdminUpdateChallengeRequestDTO
     */
    'isB2B'?: boolean;
    /**
     * 
     * @type {AdminChallengeB2bFormSchemaDTO}
     * @memberof AdminUpdateChallengeRequestDTO
     */
    'b2bFormSchema'?: AdminChallengeB2bFormSchemaDTO;
    /**
     * 
     * @type {AdminCrusherGroupDto}
     * @memberof AdminUpdateChallengeRequestDTO
     */
    'crusherGroup'?: AdminCrusherGroupDto;
    /**
     * 
     * @type {ChallengeAggregationPeriodTypeEnum}
     * @memberof AdminUpdateChallengeRequestDTO
     */
    'aggregationPeriodType'?: ChallengeAggregationPeriodTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateChallengeRequestDTO
     */
    'lastMonthRankImageUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateChallengeRequestDTO
     */
    'modalImageUrl'?: string;
    /**
     * When enabled, past contributions within challenge period are applied on join
     * @type {boolean}
     * @memberof AdminUpdateChallengeRequestDTO
     */
    'isRetroactiveContributionEnabled'?: boolean;
}
/**
 * 
 * @export
 * @interface AdminUpdatePlaceAccessibilityRequestDTO
 */
export interface AdminUpdatePlaceAccessibilityRequestDTO {
    /**
     * 
     * @type {boolean}
     * @memberof AdminUpdatePlaceAccessibilityRequestDTO
     */
    'isFirstFloor': boolean;
    /**
     * 
     * @type {AdminStairInfoDTO}
     * @memberof AdminUpdatePlaceAccessibilityRequestDTO
     */
    'stairInfo': AdminStairInfoDTO;
    /**
     * 
     * @type {boolean}
     * @memberof AdminUpdatePlaceAccessibilityRequestDTO
     */
    'hasSlope': boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof AdminUpdatePlaceAccessibilityRequestDTO
     */
    'floors'?: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof AdminUpdatePlaceAccessibilityRequestDTO
     */
    'isStairOnlyOption'?: boolean;
    /**
     * 
     * @type {AdminStairHeightLevel}
     * @memberof AdminUpdatePlaceAccessibilityRequestDTO
     */
    'stairHeightLevel'?: AdminStairHeightLevel;
    /**
     * 
     * @type {Array<AdminEntranceDoorType>}
     * @memberof AdminUpdatePlaceAccessibilityRequestDTO
     */
    'entranceDoorTypes'?: Array<AdminEntranceDoorType>;
}
/**
 * 장소 카테고리 캐시 수정 요청
 * @export
 * @interface AdminUpdatePlaceCategoryCacheRequestDto
 */
export interface AdminUpdatePlaceCategoryCacheRequestDto {
    /**
     * 
     * @type {PlaceCategoryDto}
     * @memberof AdminUpdatePlaceCategoryCacheRequestDto
     */
    'placeCategory': PlaceCategoryDto;
}
/**
 * 저장 리스트 수정 요청
 * @export
 * @interface AdminUpdatePlaceListRequestDto
 */
export interface AdminUpdatePlaceListRequestDto {
    /**
     * 
     * @type {string}
     * @memberof AdminUpdatePlaceListRequestDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AdminUpdatePlaceListRequestDto
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AdminUpdatePlaceListRequestDto
     */
    'thumbnailUrl'?: string | null;
    /**
     * 아이콘 배경색 (hex, e.g. \"#FFC01E\"). null이면 기본색 사용.
     * @type {string}
     * @memberof AdminUpdatePlaceListRequestDto
     */
    'iconColor'?: string | null;
    /**
     * 리스트에 포함할 장소 ID 목록 (기존 매핑을 대체)
     * @type {Array<string>}
     * @memberof AdminUpdatePlaceListRequestDto
     */
    'placeIds': Array<string>;
}
/**
 * 
 * @export
 * @interface AdminUpdatePushNotificationScheduleRequestDTO
 */
export interface AdminUpdatePushNotificationScheduleRequestDTO {
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof AdminUpdatePushNotificationScheduleRequestDTO
     */
    'scheduledAt': EpochMillisTimestamp;
    /**
     * 
     * @type {string}
     * @memberof AdminUpdatePushNotificationScheduleRequestDTO
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminUpdatePushNotificationScheduleRequestDTO
     */
    'body': string;
    /**
     * 
     * @type {string}
     * @memberof AdminUpdatePushNotificationScheduleRequestDTO
     */
    'deepLink'?: string;
}
/**
 * SubBuilding 수정 요청
 * @export
 * @interface AdminUpdateSubBuildingRequestDTO
 */
export interface AdminUpdateSubBuildingRequestDTO {
    /**
     * 서브 건물 이름
     * @type {string}
     * @memberof AdminUpdateSubBuildingRequestDTO
     */
    'subBuildingName': string;
    /**
     * 서브 건물 중심 경도
     * @type {number}
     * @memberof AdminUpdateSubBuildingRequestDTO
     */
    'centerLng': number;
    /**
     * 서브 건물 중심 위도
     * @type {number}
     * @memberof AdminUpdateSubBuildingRequestDTO
     */
    'centerLat': number;
    /**
     * 서브 건물 경계 (WKT Polygon 형식) 예: POLYGON((127.001 37.001, 127.002 37.001, 127.002 37.002, 127.001 37.002, 127.001 37.001)) 
     * @type {string}
     * @memberof AdminUpdateSubBuildingRequestDTO
     */
    'boundaryWkt': string;
    /**
     * 메모
     * @type {string}
     * @memberof AdminUpdateSubBuildingRequestDTO
     */
    'notes'?: string;
}
/**
 * 검수 결과 반영 시 수행된 작업
 * @export
 * @enum {string}
 */

export const AppliedActionDto = {
    Deleted: 'DELETED',
    Modified: 'MODIFIED',
    NoActionNeeded: 'NO_ACTION_NEEDED',
    Error: 'ERROR'
} as const;

export type AppliedActionDto = typeof AppliedActionDto[keyof typeof AppliedActionDto];


/**
 * 접근성 검수 결과 반영 응답
 * @export
 * @interface ApplyAccessibilityInspectionResultResponseDto
 */
export interface ApplyAccessibilityInspectionResultResponseDto {
    /**
     * 반영된 검수 결과 ID
     * @type {string}
     * @memberof ApplyAccessibilityInspectionResultResponseDto
     */
    'appliedInspectionResultId': string;
    /**
     * 
     * @type {ResultTypeDTO}
     * @memberof ApplyAccessibilityInspectionResultResponseDto
     */
    'resultType': ResultTypeDTO;
    /**
     * 
     * @type {AppliedActionDto}
     * @memberof ApplyAccessibilityInspectionResultResponseDto
     */
    'appliedAction': AppliedActionDto;
}
/**
 * 접근성 검수 결과 반영 응답 (ID 기반 및 필터 기반 모드 공통)
 * @export
 * @interface ApplyAccessibilityInspectionResultSummaryResponseDto
 */
export interface ApplyAccessibilityInspectionResultSummaryResponseDto {
    /**
     * 
     * @type {ApplySummaryDto}
     * @memberof ApplyAccessibilityInspectionResultSummaryResponseDto
     */
    'summary': ApplySummaryDto;
}
/**
 * 접근성 검수 결과 반영 요청 (ID 기반 또는 필터 기반 모드)
 * @export
 * @interface ApplyAccessibilityInspectionResultsRequestDto
 */
export interface ApplyAccessibilityInspectionResultsRequestDto {
    /**
     * (ID 기반 모드) 반영할 검수 결과 ID 목록
     * @type {Array<string>}
     * @memberof ApplyAccessibilityInspectionResultsRequestDto
     */
    'inspectionResultIds'?: Array<string>;
    /**
     * 
     * @type {ApplyFilterDto}
     * @memberof ApplyAccessibilityInspectionResultsRequestDto
     */
    'filter'?: ApplyFilterDto;
}
/**
 * 필터 기반 검수 결과 반영 조건
 * @export
 * @interface ApplyFilterDto
 */
export interface ApplyFilterDto {
    /**
     * 검수자 유형 (선택)
     * @type {string}
     * @memberof ApplyFilterDto
     */
    'inspectorType'?: ApplyFilterDtoInspectorTypeEnum;
    /**
     * 검수자 ID (선택)
     * @type {string}
     * @memberof ApplyFilterDto
     */
    'inspectorId'?: string;
    /**
     * 검수 결과 유형 (선택)
     * @type {string}
     * @memberof ApplyFilterDto
     */
    'resultType'?: ApplyFilterDtoResultTypeEnum;
}

export const ApplyFilterDtoInspectorTypeEnum = {
    Ai: 'AI',
    User: 'USER',
    Bulk: 'BULK'
} as const;

export type ApplyFilterDtoInspectorTypeEnum = typeof ApplyFilterDtoInspectorTypeEnum[keyof typeof ApplyFilterDtoInspectorTypeEnum];
export const ApplyFilterDtoResultTypeEnum = {
    Ok: 'OK',
    Modify: 'MODIFY',
    Delete: 'DELETE',
    Unknown: 'UNKNOWN'
} as const;

export type ApplyFilterDtoResultTypeEnum = typeof ApplyFilterDtoResultTypeEnum[keyof typeof ApplyFilterDtoResultTypeEnum];

/**
 * 검수 결과 반영 상태
 * @export
 * @enum {string}
 */

export const ApplyStateDto = {
    Applied: 'APPLIED',
    Error: 'ERROR'
} as const;

export type ApplyStateDto = typeof ApplyStateDto[keyof typeof ApplyStateDto];


/**
 * 검수 결과 반영 요약 정보
 * @export
 * @interface ApplySummaryDto
 */
export interface ApplySummaryDto {
    /**
     * 총 처리된 검수 결과 수
     * @type {number}
     * @memberof ApplySummaryDto
     */
    'totalProcessed': number;
    /**
     * 성공한 검수 결과 수
     * @type {number}
     * @memberof ApplySummaryDto
     */
    'successCount': number;
    /**
     * 실패한 검수 결과 수
     * @type {number}
     * @memberof ApplySummaryDto
     */
    'failureCount': number;
}
/**
 * 
 * @export
 * @interface BbucleRoadPageDTO
 */
export interface BbucleRoadPageDTO {
    /**
     * 
     * @type {string}
     * @memberof BbucleRoadPageDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BbucleRoadPageDTO
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof BbucleRoadPageDTO
     */
    'titleImageUrl': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof BbucleRoadPageDTO
     */
    'summary': Array<string>;
    /**
     * 
     * @type {Array<BbucleRoadSectionDTO>}
     * @memberof BbucleRoadPageDTO
     */
    'sections': Array<BbucleRoadSectionDTO>;
    /**
     * 
     * @type {string}
     * @memberof BbucleRoadPageDTO
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface BbucleRoadSectionDTO
 */
export interface BbucleRoadSectionDTO {
    /**
     * 
     * @type {string}
     * @memberof BbucleRoadSectionDTO
     */
    'id': string;
    /**
     * 
     * @type {BbucleRoadSectionTypeDTO}
     * @memberof BbucleRoadSectionDTO
     */
    'type': BbucleRoadSectionTypeDTO;
    /**
     * 
     * @type {string}
     * @memberof BbucleRoadSectionDTO
     */
    'title': string;
    /**
     * 
     * @type {MapConfigDTO}
     * @memberof BbucleRoadSectionDTO
     */
    'mapConfig'?: MapConfigDTO;
    /**
     * 
     * @type {Array<MapMarkerDTO>}
     * @memberof BbucleRoadSectionDTO
     */
    'markers'?: Array<MapMarkerDTO> | null;
    /**
     * 이미지 URL 목록
     * @type {Array<string>}
     * @memberof BbucleRoadSectionDTO
     */
    'imageUrls'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BbucleRoadSectionDTO
     */
    'accessibilityTips'?: string;
    /**
     * 
     * @type {number}
     * @memberof BbucleRoadSectionDTO
     */
    'order': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const BbucleRoadSectionTypeDTO = {
    MapOverview: 'MAP_OVERVIEW',
    Traffic: 'TRAFFIC',
    Ticketing: 'TICKETING',
    WheelchairView: 'WHEELCHAIR_VIEW',
    NearbyRestaurants: 'NEARBY_RESTAURANTS',
    NearbyCafes: 'NEARBY_CAFES'
} as const;

export type BbucleRoadSectionTypeDTO = typeof BbucleRoadSectionTypeDTO[keyof typeof BbucleRoadSectionTypeDTO];


/**
 * 
 * @export
 * @interface BulkImportHumanInspectionResponseDTO
 */
export interface BulkImportHumanInspectionResponseDTO {
    /**
     * 처리 상태 메시지
     * @type {string}
     * @memberof BulkImportHumanInspectionResponseDTO
     */
    'message': string;
    /**
     * CSV 파일의 전체 레코드 수
     * @type {number}
     * @memberof BulkImportHumanInspectionResponseDTO
     */
    'totalRecords': number;
    /**
     * 파싱에 성공한 레코드 수
     * @type {number}
     * @memberof BulkImportHumanInspectionResponseDTO
     */
    'parsedCount': number;
    /**
     * 파싱에 실패한 레코드 수
     * @type {number}
     * @memberof BulkImportHumanInspectionResponseDTO
     */
    'parseErrors': number;
    /**
     * 등록에 성공한 레코드 수 (비동기 처리시 null)
     * @type {number}
     * @memberof BulkImportHumanInspectionResponseDTO
     */
    'successCount'?: number | null;
    /**
     * 등록에 실패한 레코드 수 (비동기 처리시 null)
     * @type {number}
     * @memberof BulkImportHumanInspectionResponseDTO
     */
    'failureCount'?: number | null;
    /**
     * 실패한 레코드의 에러 메시지 목록 (비동기 처리시 null)
     * @type {Array<string>}
     * @memberof BulkImportHumanInspectionResponseDTO
     */
    'errors'?: Array<string> | null;
    /**
     * 비동기 처리 여부 (true면 백그라운드 처리중)
     * @type {boolean}
     * @memberof BulkImportHumanInspectionResponseDTO
     */
    'asyncProcessing': boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ChallengeAggregationPeriodTypeEnum = {
    AllTime: 'ALL_TIME',
    Monthly: 'MONTHLY'
} as const;

export type ChallengeAggregationPeriodTypeEnum = typeof ChallengeAggregationPeriodTypeEnum[keyof typeof ChallengeAggregationPeriodTypeEnum];


/**
 * 퀘스트 생성 시뮬레이션 결과. 각 퀘스트마다 1개의 아이템이 반환된다.
 * @export
 * @interface ClubQuestCreateDryRunResultItemDTO
 */
export interface ClubQuestCreateDryRunResultItemDTO {
    /**
     * 
     * @type {string}
     * @memberof ClubQuestCreateDryRunResultItemDTO
     */
    'questNamePostfix': string;
    /**
     * 
     * @type {LocationDTO}
     * @memberof ClubQuestCreateDryRunResultItemDTO
     */
    'questCenterLocation': LocationDTO;
    /**
     * 
     * @type {Array<ClubQuestTargetBuildingDTO>}
     * @memberof ClubQuestCreateDryRunResultItemDTO
     */
    'targetBuildings': Array<ClubQuestTargetBuildingDTO>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ClubQuestCreateRegionTypeDTO = {
    Circle: 'CIRCLE',
    Polygon: 'POLYGON'
} as const;

export type ClubQuestCreateRegionTypeDTO = typeof ClubQuestCreateRegionTypeDTO[keyof typeof ClubQuestCreateRegionTypeDTO];


/**
 * 퀘스트.
 * @export
 * @interface ClubQuestDTO
 */
export interface ClubQuestDTO {
    /**
     * 
     * @type {string}
     * @memberof ClubQuestDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ClubQuestDTO
     */
    'name': string;
    /**
     * 퀘스트 그룹 식별자 (dryRun 배치 단위). 같은 groupId를 가진 퀘스트들은 동일한 배치로 생성됨.
     * @type {string}
     * @memberof ClubQuestDTO
     */
    'groupId'?: string;
    /**
     * 
     * @type {ClubQuestPurposeTypeEnumDTO}
     * @memberof ClubQuestDTO
     */
    'purposeType': ClubQuestPurposeTypeEnumDTO;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof ClubQuestDTO
     */
    'startAt': EpochMillisTimestamp;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof ClubQuestDTO
     */
    'endAt': EpochMillisTimestamp;
    /**
     * 
     * @type {Array<ClubQuestTargetBuildingDTO>}
     * @memberof ClubQuestDTO
     */
    'buildings': Array<ClubQuestTargetBuildingDTO>;
    /**
     * 
     * @type {string}
     * @memberof ClubQuestDTO
     */
    'shortenedUrl'?: string;
    /**
     * 출석체크 가능 여부
     * @type {boolean}
     * @memberof ClubQuestDTO
     */
    'isAttendanceCheckEnabled'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ClubQuestPurposeTypeEnumDTO = {
    CrusherClub: 'CRUSHER_CLUB',
    DailyClub: 'DAILY_CLUB',
    CollaboClub: 'COLLABO_CLUB',
    EsgPartners: 'ESG_PARTNERS'
} as const;

export type ClubQuestPurposeTypeEnumDTO = typeof ClubQuestPurposeTypeEnumDTO[keyof typeof ClubQuestPurposeTypeEnumDTO];


/**
 * 
 * @export
 * @interface ClubQuestSummaryDTO
 */
export interface ClubQuestSummaryDTO {
    /**
     * 
     * @type {string}
     * @memberof ClubQuestSummaryDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ClubQuestSummaryDTO
     */
    'name': string;
    /**
     * 
     * @type {ClubQuestPurposeTypeEnumDTO}
     * @memberof ClubQuestSummaryDTO
     */
    'purposeType': ClubQuestPurposeTypeEnumDTO;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof ClubQuestSummaryDTO
     */
    'startAt': EpochMillisTimestamp;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof ClubQuestSummaryDTO
     */
    'endAt': EpochMillisTimestamp;
    /**
     * 
     * @type {string}
     * @memberof ClubQuestSummaryDTO
     */
    'shortenedUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClubQuestSummaryDTO
     */
    'groupId'?: string;
}
/**
 * 퀘스트 대상이 되는 건물 정보.
 * @export
 * @interface ClubQuestTargetBuildingDTO
 */
export interface ClubQuestTargetBuildingDTO {
    /**
     * 
     * @type {string}
     * @memberof ClubQuestTargetBuildingDTO
     */
    'buildingId': string;
    /**
     * 
     * @type {string}
     * @memberof ClubQuestTargetBuildingDTO
     */
    'name': string;
    /**
     * 
     * @type {LocationDTO}
     * @memberof ClubQuestTargetBuildingDTO
     */
    'location': LocationDTO;
    /**
     * 
     * @type {Array<ClubQuestTargetPlaceDTO>}
     * @memberof ClubQuestTargetBuildingDTO
     */
    'places': Array<ClubQuestTargetPlaceDTO>;
}
/**
 * 퀘스트 대상이 되는 점포 정보.
 * @export
 * @interface ClubQuestTargetPlaceDTO
 */
export interface ClubQuestTargetPlaceDTO {
    /**
     * 점포의 ID.
     * @type {string}
     * @memberof ClubQuestTargetPlaceDTO
     */
    'placeId': string;
    /**
     * 건물의 ID.
     * @type {string}
     * @memberof ClubQuestTargetPlaceDTO
     */
    'buildingId': string;
    /**
     * 점포의 human-readable한 이름.
     * @type {string}
     * @memberof ClubQuestTargetPlaceDTO
     */
    'name': string;
    /**
     * 
     * @type {LocationDTO}
     * @memberof ClubQuestTargetPlaceDTO
     */
    'location': LocationDTO;
    /**
     * 장소가 정복됐는지 여부.
     * @type {boolean}
     * @memberof ClubQuestTargetPlaceDTO
     */
    'isConquered': boolean;
    /**
     * 장소가 폐업으로 추정되는지 여부.
     * @type {boolean}
     * @memberof ClubQuestTargetPlaceDTO
     */
    'isClosedExpected': boolean;
    /**
     * 장소가 실제로 폐업됐는지 여부.
     * @type {boolean}
     * @memberof ClubQuestTargetPlaceDTO
     */
    'isClosed': boolean;
    /**
     * 장소에 접근 가능한지 여부.
     * @type {boolean}
     * @memberof ClubQuestTargetPlaceDTO
     */
    'isNotAccessible': boolean;
}
/**
 * 
 * @export
 * @interface ClubQuestsClubQuestIdIsClosedPutRequest
 */
export interface ClubQuestsClubQuestIdIsClosedPutRequest {
    /**
     * 
     * @type {string}
     * @memberof ClubQuestsClubQuestIdIsClosedPutRequest
     */
    'buildingId': string;
    /**
     * 
     * @type {string}
     * @memberof ClubQuestsClubQuestIdIsClosedPutRequest
     */
    'placeId': string;
    /**
     * 
     * @type {boolean}
     * @memberof ClubQuestsClubQuestIdIsClosedPutRequest
     */
    'isClosed': boolean;
}
/**
 * 
 * @export
 * @interface ClubQuestsClubQuestIdIsNotAccessiblePutRequest
 */
export interface ClubQuestsClubQuestIdIsNotAccessiblePutRequest {
    /**
     * 
     * @type {string}
     * @memberof ClubQuestsClubQuestIdIsNotAccessiblePutRequest
     */
    'buildingId': string;
    /**
     * 
     * @type {string}
     * @memberof ClubQuestsClubQuestIdIsNotAccessiblePutRequest
     */
    'placeId': string;
    /**
     * 
     * @type {boolean}
     * @memberof ClubQuestsClubQuestIdIsNotAccessiblePutRequest
     */
    'isNotAccessible': boolean;
}
/**
 * 
 * @export
 * @interface ClubQuestsCreateDryRunPostRequest
 */
export interface ClubQuestsCreateDryRunPostRequest {
    /**
     * 
     * @type {ClubQuestCreateRegionTypeDTO}
     * @memberof ClubQuestsCreateDryRunPostRequest
     */
    'regionType'?: ClubQuestCreateRegionTypeDTO;
    /**
     * 
     * @type {LocationDTO}
     * @memberof ClubQuestsCreateDryRunPostRequest
     */
    'centerLocation'?: LocationDTO;
    /**
     * 
     * @type {number}
     * @memberof ClubQuestsCreateDryRunPostRequest
     */
    'radiusMeters'?: number;
    /**
     * 
     * @type {Array<LocationDTO>}
     * @memberof ClubQuestsCreateDryRunPostRequest
     */
    'points'?: Array<LocationDTO>;
    /**
     * 
     * @type {number}
     * @memberof ClubQuestsCreateDryRunPostRequest
     */
    'clusterCount': number;
    /**
     * 
     * @type {number}
     * @memberof ClubQuestsCreateDryRunPostRequest
     */
    'maxPlaceCountPerQuest': number;
    /**
     * 지도 API 기반이 아닌, 이미 크롤링하여 계단정복지도 서버 DB에 캐싱해둔 장소를 기반으로 퀘스트를 생성할지 여부. 지정되지 않은 경우, default는 false. 
     * @type {boolean}
     * @memberof ClubQuestsCreateDryRunPostRequest
     */
    'useAlreadyCrawledPlace'?: boolean;
    /**
     * 
     * @type {Array<QuestTargetPlaceCategoryEnumDTO>}
     * @memberof ClubQuestsCreateDryRunPostRequest
     */
    'questTargetPlaceCategories'?: Array<QuestTargetPlaceCategoryEnumDTO>;
}
/**
 * 
 * @export
 * @interface CreateAccessibilityAllowedRegionRequestDTO
 */
export interface CreateAccessibilityAllowedRegionRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateAccessibilityAllowedRegionRequestDTO
     */
    'name': string;
    /**
     * 
     * @type {Array<LocationDTO>}
     * @memberof CreateAccessibilityAllowedRegionRequestDTO
     */
    'boundaryVertices': Array<LocationDTO>;
}
/**
 * 
 * @export
 * @interface CreateAndNotifyDailyClubQuestRequestDTO
 */
export interface CreateAndNotifyDailyClubQuestRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateAndNotifyDailyClubQuestRequestDTO
     */
    'requesterName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAndNotifyDailyClubQuestRequestDTO
     */
    'requesterPhoneNumber': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAndNotifyDailyClubQuestRequestDTO
     */
    'centerLocationPlaceName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAndNotifyDailyClubQuestRequestDTO
     */
    'maxPlaceCountPerQuest': string;
}
/**
 * 
 * @export
 * @interface CreateAndNotifyDailyClubQuestResponseDTO
 */
export interface CreateAndNotifyDailyClubQuestResponseDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateAndNotifyDailyClubQuestResponseDTO
     */
    'clubQuestId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateAndNotifyDailyClubQuestResponseDTO
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface CreateBbucleRoadPageRequestDTO
 */
export interface CreateBbucleRoadPageRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateBbucleRoadPageRequestDTO
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CreateBbucleRoadPageRequestDTO
     */
    'titleImageUrl': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateBbucleRoadPageRequestDTO
     */
    'summary': Array<string>;
    /**
     * 
     * @type {Array<CreateBbucleRoadSectionDTO>}
     * @memberof CreateBbucleRoadPageRequestDTO
     */
    'sections': Array<CreateBbucleRoadSectionDTO>;
}
/**
 * 
 * @export
 * @interface CreateBbucleRoadSectionDTO
 */
export interface CreateBbucleRoadSectionDTO {
    /**
     * 
     * @type {BbucleRoadSectionTypeDTO}
     * @memberof CreateBbucleRoadSectionDTO
     */
    'type': BbucleRoadSectionTypeDTO;
    /**
     * 
     * @type {string}
     * @memberof CreateBbucleRoadSectionDTO
     */
    'title': string;
    /**
     * 
     * @type {MapConfigDTO}
     * @memberof CreateBbucleRoadSectionDTO
     */
    'mapConfig'?: MapConfigDTO;
    /**
     * 
     * @type {Array<CreateMapMarkerDTO>}
     * @memberof CreateBbucleRoadSectionDTO
     */
    'markers'?: Array<CreateMapMarkerDTO> | null;
    /**
     * 이미지 URL 목록
     * @type {Array<string>}
     * @memberof CreateBbucleRoadSectionDTO
     */
    'imageUrls'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateBbucleRoadSectionDTO
     */
    'accessibilityTips'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateBbucleRoadSectionDTO
     */
    'order': number;
}
/**
 * 
 * @export
 * @interface CreateClubQuestRequest
 */
export interface CreateClubQuestRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateClubQuestRequest
     */
    'questNamePrefix': string;
    /**
     * 
     * @type {ClubQuestPurposeTypeEnumDTO}
     * @memberof CreateClubQuestRequest
     */
    'purposeType': ClubQuestPurposeTypeEnumDTO;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof CreateClubQuestRequest
     */
    'startAt': EpochMillisTimestamp;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof CreateClubQuestRequest
     */
    'endAt': EpochMillisTimestamp;
    /**
     * 출석체크 가능 여부
     * @type {boolean}
     * @memberof CreateClubQuestRequest
     */
    'isAttendanceCheckEnabled'?: boolean;
    /**
     * 
     * @type {Array<ClubQuestCreateDryRunResultItemDTO>}
     * @memberof CreateClubQuestRequest
     */
    'dryRunResults': Array<ClubQuestCreateDryRunResultItemDTO>;
}
/**
 * 
 * @export
 * @interface CreateClubQuestResponseDTO
 */
export interface CreateClubQuestResponseDTO {
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateClubQuestResponseDTO
     */
    'clubQuestIds': Array<string>;
}
/**
 * 
 * @export
 * @interface CreateMapMarkerDTO
 */
export interface CreateMapMarkerDTO {
    /**
     * 
     * @type {MarkerCategoryDTO}
     * @memberof CreateMapMarkerDTO
     */
    'category': MarkerCategoryDTO;
    /**
     * 
     * @type {LocationDTO}
     * @memberof CreateMapMarkerDTO
     */
    'position': LocationDTO;
    /**
     * 
     * @type {string}
     * @memberof CreateMapMarkerDTO
     */
    'tooltipText': string;
    /**
     * 
     * @type {MarkerSizeDTO}
     * @memberof CreateMapMarkerDTO
     */
    'size'?: MarkerSizeDTO;
    /**
     * 
     * @type {string}
     * @memberof CreateMapMarkerDTO
     */
    'customImageUrl'?: string;
}
/**
 * 특정 시각을 표현하기 위한 모델.
 * @export
 * @interface EpochMillisTimestamp
 */
export interface EpochMillisTimestamp {
    /**
     * 
     * @type {number}
     * @memberof EpochMillisTimestamp
     */
    'value': number;
}
/**
 * groupId로 조회한 퀘스트 목록
 * @export
 * @interface GetClubQuestsByGroupIdResult
 */
export interface GetClubQuestsByGroupIdResult {
    /**
     * 
     * @type {Array<ClubQuestDTO>}
     * @memberof GetClubQuestsByGroupIdResult
     */
    'items': Array<ClubQuestDTO>;
}
/**
 * 
 * @export
 * @interface GetCursoredClubQuestSummariesResultDTO
 */
export interface GetCursoredClubQuestSummariesResultDTO {
    /**
     * 
     * @type {Array<ClubQuestSummaryDTO>}
     * @memberof GetCursoredClubQuestSummariesResultDTO
     */
    'list': Array<ClubQuestSummaryDTO>;
    /**
     * 없으면 다음 페이지가 없다는 의미.
     * @type {string}
     * @memberof GetCursoredClubQuestSummariesResultDTO
     */
    'cursor'?: string;
}
/**
 * 
 * @export
 * @interface GetSearchPreset200Response
 */
export interface GetSearchPreset200Response {
    /**
     * 
     * @type {Array<AdminSearchPlacePresetDTO>}
     * @memberof GetSearchPreset200Response
     */
    'presets': Array<AdminSearchPlacePresetDTO>;
}
/**
 * 홈 배너 타입
 * @export
 * @enum {string}
 */

export const HomeBannerTypeDTO = {
    Main: 'MAIN',
    Strip: 'STRIP'
} as const;

export type HomeBannerTypeDTO = typeof HomeBannerTypeDTO[keyof typeof HomeBannerTypeDTO];


/**
 * 
 * @export
 * @enum {string}
 */

export const InspectorTypeDTO = {
    Human: 'HUMAN',
    Ai: 'AI',
    Unknown: 'UNKNOWN'
} as const;

export type InspectorTypeDTO = typeof InspectorTypeDTO[keyof typeof InspectorTypeDTO];


/**
 * 위치를 위경도로 표현하기 위한 모델.
 * @export
 * @interface LocationDTO
 */
export interface LocationDTO {
    /**
     * 
     * @type {number}
     * @memberof LocationDTO
     */
    'lng': number;
    /**
     * 
     * @type {number}
     * @memberof LocationDTO
     */
    'lat': number;
}
/**
 * 
 * @export
 * @interface LoginPostRequest
 */
export interface LoginPostRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginPostRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof LoginPostRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface MapConfigDTO
 */
export interface MapConfigDTO {
    /**
     * 
     * @type {LocationDTO}
     * @memberof MapConfigDTO
     */
    'center'?: LocationDTO;
    /**
     * 지도 확대 레벨 (1-14)
     * @type {number}
     * @memberof MapConfigDTO
     */
    'level'?: number;
}
/**
 * 
 * @export
 * @interface MapMarkerDTO
 */
export interface MapMarkerDTO {
    /**
     * 
     * @type {string}
     * @memberof MapMarkerDTO
     */
    'id': string;
    /**
     * 
     * @type {MarkerCategoryDTO}
     * @memberof MapMarkerDTO
     */
    'category': MarkerCategoryDTO;
    /**
     * 
     * @type {LocationDTO}
     * @memberof MapMarkerDTO
     */
    'position': LocationDTO;
    /**
     * 
     * @type {string}
     * @memberof MapMarkerDTO
     */
    'tooltipText': string;
    /**
     * 
     * @type {MarkerSizeDTO}
     * @memberof MapMarkerDTO
     */
    'size'?: MarkerSizeDTO;
    /**
     * 
     * @type {string}
     * @memberof MapMarkerDTO
     */
    'customImageUrl'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MarkerCategoryDTO = {
    Restaurant: 'RESTAURANT',
    Cafe: 'CAFE',
    AccessibleToilet: 'ACCESSIBLE_TOILET',
    AccessibilityInfo: 'ACCESSIBILITY_INFO',
    TicketBooth: 'TICKET_BOOTH',
    Entrance: 'ENTRANCE',
    Elevator: 'ELEVATOR',
    SubwayExit: 'SUBWAY_EXIT',
    BusStop: 'BUS_STOP',
    Parking: 'PARKING',
    Custom: 'CUSTOM'
} as const;

export type MarkerCategoryDTO = typeof MarkerCategoryDTO[keyof typeof MarkerCategoryDTO];


/**
 * 
 * @export
 * @interface MarkerSizeDTO
 */
export interface MarkerSizeDTO {
    /**
     * 
     * @type {number}
     * @memberof MarkerSizeDTO
     */
    'width': number;
    /**
     * 
     * @type {number}
     * @memberof MarkerSizeDTO
     */
    'height': number;
}
/**
 * 장소 이동 요청
 * @export
 * @interface MoveClubQuestTargetPlaceRequest
 */
export interface MoveClubQuestTargetPlaceRequest {
    /**
     * 이동 대상 퀘스트 ID
     * @type {string}
     * @memberof MoveClubQuestTargetPlaceRequest
     */
    'targetQuestId': string;
    /**
     * 이동할 장소 ID 목록
     * @type {Array<string>}
     * @memberof MoveClubQuestTargetPlaceRequest
     */
    'placeIds': Array<string>;
}
/**
 * 장소 이동 응답
 * @export
 * @interface MoveClubQuestTargetPlaceResponse
 */
export interface MoveClubQuestTargetPlaceResponse {
    /**
     * 
     * @type {ClubQuestDTO}
     * @memberof MoveClubQuestTargetPlaceResponse
     */
    'sourceQuest': ClubQuestDTO;
    /**
     * 
     * @type {ClubQuestDTO}
     * @memberof MoveClubQuestTargetPlaceResponse
     */
    'targetQuest': ClubQuestDTO;
}
/**
 * 장소 카테고리 enum
 * @export
 * @enum {string}
 */

export const PlaceCategoryDto = {
    Market: 'MARKET',
    ConvenienceStore: 'CONVENIENCE_STORE',
    Kindergarten: 'KINDERGARTEN',
    School: 'SCHOOL',
    Academy: 'ACADEMY',
    ParkingLot: 'PARKING_LOT',
    GasStation: 'GAS_STATION',
    SubwayStation: 'SUBWAY_STATION',
    Bank: 'BANK',
    CulturalFacilities: 'CULTURAL_FACILITIES',
    Agency: 'AGENCY',
    PublicOffice: 'PUBLIC_OFFICE',
    Attraction: 'ATTRACTION',
    Accomodation: 'ACCOMODATION',
    Restaurant: 'RESTAURANT',
    Cafe: 'CAFE',
    Hospital: 'HOSPITAL',
    Pharmacy: 'PHARMACY'
} as const;

export type PlaceCategoryDto = typeof PlaceCategoryDto[keyof typeof PlaceCategoryDto];


/**
 * 
 * @export
 * @enum {string}
 */

export const QuestTargetPlaceCategoryEnumDTO = {
    Restaurant: 'RESTAURANT',
    Cafe: 'CAFE',
    Market: 'MARKET',
    Hospital: 'HOSPITAL',
    Pharmacy: 'PHARMACY',
    ConvenienceStore: 'CONVENIENCE_STORE'
} as const;

export type QuestTargetPlaceCategoryEnumDTO = typeof QuestTargetPlaceCategoryEnumDTO[keyof typeof QuestTargetPlaceCategoryEnumDTO];


/**
 * 
 * @export
 * @enum {string}
 */

export const ResultTypeDTO = {
    Ok: 'OK',
    Modify: 'MODIFY',
    Delete: 'DELETE',
    Unknown: 'UNKNOWN'
} as const;

export type ResultTypeDTO = typeof ResultTypeDTO[keyof typeof ResultTypeDTO];


/**
 * 
 * @export
 * @interface RunAccessibilityImagePipelineRequest
 */
export interface RunAccessibilityImagePipelineRequest {
    /**
     * 
     * @type {Array<RunAccessibilityImagePipelineRequestItemsInner>}
     * @memberof RunAccessibilityImagePipelineRequest
     */
    'items': Array<RunAccessibilityImagePipelineRequestItemsInner>;
}
/**
 * 
 * @export
 * @interface RunAccessibilityImagePipelineRequestItemsInner
 */
export interface RunAccessibilityImagePipelineRequestItemsInner {
    /**
     * 
     * @type {string}
     * @memberof RunAccessibilityImagePipelineRequestItemsInner
     */
    'accessibilityId': string;
    /**
     * 
     * @type {AccessibilityTypeDTO}
     * @memberof RunAccessibilityImagePipelineRequestItemsInner
     */
    'accessibilityType': AccessibilityTypeDTO;
}
/**
 * 
 * @export
 * @interface StartPlaceCrawlingRequestDTO
 */
export interface StartPlaceCrawlingRequestDTO {
    /**
     * 
     * @type {Array<LocationDTO>}
     * @memberof StartPlaceCrawlingRequestDTO
     */
    'boundaryVertices': Array<LocationDTO>;
}
/**
 * 
 * @export
 * @interface UpdateBbucleRoadPageRequestDTO
 */
export interface UpdateBbucleRoadPageRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof UpdateBbucleRoadPageRequestDTO
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBbucleRoadPageRequestDTO
     */
    'titleImageUrl': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateBbucleRoadPageRequestDTO
     */
    'summary': Array<string>;
    /**
     * 
     * @type {Array<UpdateBbucleRoadSectionDTO>}
     * @memberof UpdateBbucleRoadPageRequestDTO
     */
    'sections': Array<UpdateBbucleRoadSectionDTO>;
}
/**
 * 
 * @export
 * @interface UpdateBbucleRoadSectionDTO
 */
export interface UpdateBbucleRoadSectionDTO {
    /**
     * 기존 섹션은 id가 있고, 새 섹션은 null
     * @type {string}
     * @memberof UpdateBbucleRoadSectionDTO
     */
    'id'?: string;
    /**
     * 
     * @type {BbucleRoadSectionTypeDTO}
     * @memberof UpdateBbucleRoadSectionDTO
     */
    'type': BbucleRoadSectionTypeDTO;
    /**
     * 
     * @type {string}
     * @memberof UpdateBbucleRoadSectionDTO
     */
    'title': string;
    /**
     * 
     * @type {MapConfigDTO}
     * @memberof UpdateBbucleRoadSectionDTO
     */
    'mapConfig'?: MapConfigDTO;
    /**
     * 
     * @type {Array<UpdateMapMarkerDTO>}
     * @memberof UpdateBbucleRoadSectionDTO
     */
    'markers'?: Array<UpdateMapMarkerDTO> | null;
    /**
     * 이미지 URL 목록
     * @type {Array<string>}
     * @memberof UpdateBbucleRoadSectionDTO
     */
    'imageUrls'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateBbucleRoadSectionDTO
     */
    'accessibilityTips'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateBbucleRoadSectionDTO
     */
    'order': number;
}
/**
 * 
 * @export
 * @interface UpdateMapMarkerDTO
 */
export interface UpdateMapMarkerDTO {
    /**
     * 기존 마커는 id가 있고, 새 마커는 null
     * @type {string}
     * @memberof UpdateMapMarkerDTO
     */
    'id'?: string;
    /**
     * 
     * @type {MarkerCategoryDTO}
     * @memberof UpdateMapMarkerDTO
     */
    'category': MarkerCategoryDTO;
    /**
     * 
     * @type {LocationDTO}
     * @memberof UpdateMapMarkerDTO
     */
    'position': LocationDTO;
    /**
     * 
     * @type {string}
     * @memberof UpdateMapMarkerDTO
     */
    'tooltipText': string;
    /**
     * 
     * @type {MarkerSizeDTO}
     * @memberof UpdateMapMarkerDTO
     */
    'size'?: MarkerSizeDTO;
    /**
     * 
     * @type {string}
     * @memberof UpdateMapMarkerDTO
     */
    'customImageUrl'?: string;
}

/**
 * AccessibilityApi - axios parameter creator
 * @export
 */
export const AccessibilityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 검수 결과 목록을 실제 접근성 정보에 일괄 반영합니다. - DELETE: 접근성 정보를 hard delete (관련 데이터 및 도메인 이벤트 포함) - MODIFY: PlaceAccessibility를 수정 요청에 따라 업데이트 - OK: 아무 작업도 하지 않음  이미 반영된 검수 결과(handledAt != null)는 중복 처리하지 않습니다. 각 검수 결과는 개별 트랜잭션으로 처리되어, 일부 실패해도 다른 결과는 계속 처리됩니다.  ## 두 가지 모드 지원: 1. **ID 기반 모드**: `inspectionResultIds` 배열을 제공하여 특정 검수 결과들을 반영 2. **필터 기반 모드**: `filter` 객체를 제공하여 조건에 맞는 모든 미처리 검수 결과를 반영  두 모드는 상호 배타적이며, 둘 중 하나만 제공해야 합니다. 
         * @summary 접근성 이미지 검증 결과를 일괄로 반영한다.
         * @param {ApplyAccessibilityInspectionResultsRequestDto} applyAccessibilityInspectionResultsRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyAccessibilityInspectionResults: async (applyAccessibilityInspectionResultsRequestDto: ApplyAccessibilityInspectionResultsRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applyAccessibilityInspectionResultsRequestDto' is not null or undefined
            assertParamExists('applyAccessibilityInspectionResults', 'applyAccessibilityInspectionResultsRequestDto', applyAccessibilityInspectionResultsRequestDto)
            const localVarPath = `/accessibility-inspection-results/apply`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applyAccessibilityInspectionResultsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Korean inspection sheet format (30 columns) CSV 파일을 업로드하여 인간 검수 결과를 일괄로 등록합니다. 100개 이하의 레코드는 동기 처리되며, 100개 초과시 비동기로 처리됩니다.  CSV 포맷: - 30개 컬럼의 한국어 검수 시트 형식 - Column 0: 장소 id (accessibilityId) - Column 15: 판정 (status: \"정상\"=PASS, \"삭제 대상\"=FAIL, \"수정 대상\"=MODIFY) - Column 16: (선택) 추가 의견 (comment) - Column 9: 코멘트 (reason - original comment) - Columns 20-25: Modification request (1층 여부, 층 수, 계단 개수, 계단 높이, 경사로 유무, 문 유형) - Column 29: 검수자 (inspector name) 
         * @summary CSV 파일을 업로드하여 인간 검수 결과를 일괄 등록한다.
         * @param {File} file CSV 파일
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkImportHumanInspections: async (file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('bulkImportHumanInspections', 'file', file)
            const localVarPath = `/accessibility-inspection-results/human/bulk-import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 건물 정보를 삭제한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuildingAccessibility: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteBuildingAccessibility', 'id', id)
            const localVarPath = `/building-accessibilities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 장소 정보를 삭제한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaceAccessibility: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePlaceAccessibility', 'id', id)
            const localVarPath = `/place-accessibilities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 접근성 정보의 이미지 파이프라인을 실행한다.
         * @param {RunAccessibilityImagePipelineRequest} runAccessibilityImagePipelineRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runAccessibilityImagePipeline: async (runAccessibilityImagePipelineRequest: RunAccessibilityImagePipelineRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'runAccessibilityImagePipelineRequest' is not null or undefined
            assertParamExists('runAccessibilityImagePipeline', 'runAccessibilityImagePipelineRequest', runAccessibilityImagePipelineRequest)
            const localVarPath = `/accessibility/run-image-pipeline`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runAccessibilityImagePipelineRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 장소 & 건물 정보를 검색한다.
         * @param {string} [placeName] 
         * @param {string} [createdAtFromLocalDate] yyyy-MM-dd 형식
         * @param {string} [createdAtToLocalDate] yyyy-MM-dd 형식
         * @param {string} [cursor] 
         * @param {string} [limit] default 값은 20으로 설정된다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAccessibilities: async (placeName?: string, createdAtFromLocalDate?: string, createdAtToLocalDate?: string, cursor?: string, limit?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accessibilities/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (placeName !== undefined) {
                localVarQueryParameter['placeName'] = placeName;
            }

            if (createdAtFromLocalDate !== undefined) {
                localVarQueryParameter['createdAtFromLocalDate'] = createdAtFromLocalDate;
            }

            if (createdAtToLocalDate !== undefined) {
                localVarQueryParameter['createdAtToLocalDate'] = createdAtToLocalDate;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 접근성 이미지 검증 결과를 검색한다.
         * @param {string} [id] 
         * @param {AccessibilityTypeDTO} [accessibilityType] 
         * @param {InspectorTypeDTO} [inspectorType] 
         * @param {ResultTypeDTO} [resultType] 
         * @param {boolean} [isHandled] 
         * @param {number} [createdAtFrom] 검색 시작 시각 (epoch milliseconds, inclusive)
         * @param {number} [createdAtTo] 검색 종료 시각 (epoch milliseconds, exclusive)
         * @param {string} [cursor] 
         * @param {string} [limit] default 값은 20으로 설정된다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAccessibilityInspectionResults: async (id?: string, accessibilityType?: AccessibilityTypeDTO, inspectorType?: InspectorTypeDTO, resultType?: ResultTypeDTO, isHandled?: boolean, createdAtFrom?: number, createdAtTo?: number, cursor?: string, limit?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accessibility-inspection-results/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (accessibilityType !== undefined) {
                localVarQueryParameter['accessibilityType'] = accessibilityType;
            }

            if (inspectorType !== undefined) {
                localVarQueryParameter['inspectorType'] = inspectorType;
            }

            if (resultType !== undefined) {
                localVarQueryParameter['resultType'] = resultType;
            }

            if (isHandled !== undefined) {
                localVarQueryParameter['isHandled'] = isHandled;
            }

            if (createdAtFrom !== undefined) {
                localVarQueryParameter['createdAtFrom'] = createdAtFrom;
            }

            if (createdAtTo !== undefined) {
                localVarQueryParameter['createdAtTo'] = createdAtTo;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 건물 정보를 업데이트한다.
         * @param {string} id 
         * @param {AdminUpdateBuildingAccessibilityRequestDTO} adminUpdateBuildingAccessibilityRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuildingAccessibility: async (id: string, adminUpdateBuildingAccessibilityRequestDTO: AdminUpdateBuildingAccessibilityRequestDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateBuildingAccessibility', 'id', id)
            // verify required parameter 'adminUpdateBuildingAccessibilityRequestDTO' is not null or undefined
            assertParamExists('updateBuildingAccessibility', 'adminUpdateBuildingAccessibilityRequestDTO', adminUpdateBuildingAccessibilityRequestDTO)
            const localVarPath = `/building-accessibilities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminUpdateBuildingAccessibilityRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 장소 정보를 업데이트한다.
         * @param {string} id 
         * @param {AdminUpdatePlaceAccessibilityRequestDTO} adminUpdatePlaceAccessibilityRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlaceAccessibility: async (id: string, adminUpdatePlaceAccessibilityRequestDTO: AdminUpdatePlaceAccessibilityRequestDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePlaceAccessibility', 'id', id)
            // verify required parameter 'adminUpdatePlaceAccessibilityRequestDTO' is not null or undefined
            assertParamExists('updatePlaceAccessibility', 'adminUpdatePlaceAccessibilityRequestDTO', adminUpdatePlaceAccessibilityRequestDTO)
            const localVarPath = `/place-accessibilities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminUpdatePlaceAccessibilityRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessibilityApi - functional programming interface
 * @export
 */
export const AccessibilityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessibilityApiAxiosParamCreator(configuration)
    return {
        /**
         * 검수 결과 목록을 실제 접근성 정보에 일괄 반영합니다. - DELETE: 접근성 정보를 hard delete (관련 데이터 및 도메인 이벤트 포함) - MODIFY: PlaceAccessibility를 수정 요청에 따라 업데이트 - OK: 아무 작업도 하지 않음  이미 반영된 검수 결과(handledAt != null)는 중복 처리하지 않습니다. 각 검수 결과는 개별 트랜잭션으로 처리되어, 일부 실패해도 다른 결과는 계속 처리됩니다.  ## 두 가지 모드 지원: 1. **ID 기반 모드**: `inspectionResultIds` 배열을 제공하여 특정 검수 결과들을 반영 2. **필터 기반 모드**: `filter` 객체를 제공하여 조건에 맞는 모든 미처리 검수 결과를 반영  두 모드는 상호 배타적이며, 둘 중 하나만 제공해야 합니다. 
         * @summary 접근성 이미지 검증 결과를 일괄로 반영한다.
         * @param {ApplyAccessibilityInspectionResultsRequestDto} applyAccessibilityInspectionResultsRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async applyAccessibilityInspectionResults(applyAccessibilityInspectionResultsRequestDto: ApplyAccessibilityInspectionResultsRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplyAccessibilityInspectionResultSummaryResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.applyAccessibilityInspectionResults(applyAccessibilityInspectionResultsRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Korean inspection sheet format (30 columns) CSV 파일을 업로드하여 인간 검수 결과를 일괄로 등록합니다. 100개 이하의 레코드는 동기 처리되며, 100개 초과시 비동기로 처리됩니다.  CSV 포맷: - 30개 컬럼의 한국어 검수 시트 형식 - Column 0: 장소 id (accessibilityId) - Column 15: 판정 (status: \"정상\"=PASS, \"삭제 대상\"=FAIL, \"수정 대상\"=MODIFY) - Column 16: (선택) 추가 의견 (comment) - Column 9: 코멘트 (reason - original comment) - Columns 20-25: Modification request (1층 여부, 층 수, 계단 개수, 계단 높이, 경사로 유무, 문 유형) - Column 29: 검수자 (inspector name) 
         * @summary CSV 파일을 업로드하여 인간 검수 결과를 일괄 등록한다.
         * @param {File} file CSV 파일
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkImportHumanInspections(file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkImportHumanInspectionResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkImportHumanInspections(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 건물 정보를 삭제한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBuildingAccessibility(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBuildingAccessibility(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 장소 정보를 삭제한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePlaceAccessibility(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePlaceAccessibility(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 접근성 정보의 이미지 파이프라인을 실행한다.
         * @param {RunAccessibilityImagePipelineRequest} runAccessibilityImagePipelineRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runAccessibilityImagePipeline(runAccessibilityImagePipelineRequest: RunAccessibilityImagePipelineRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runAccessibilityImagePipeline(runAccessibilityImagePipelineRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 장소 & 건물 정보를 검색한다.
         * @param {string} [placeName] 
         * @param {string} [createdAtFromLocalDate] yyyy-MM-dd 형식
         * @param {string} [createdAtToLocalDate] yyyy-MM-dd 형식
         * @param {string} [cursor] 
         * @param {string} [limit] default 값은 20으로 설정된다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAccessibilities(placeName?: string, createdAtFromLocalDate?: string, createdAtToLocalDate?: string, cursor?: string, limit?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminSearchAccessibilitiesResultDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchAccessibilities(placeName, createdAtFromLocalDate, createdAtToLocalDate, cursor, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 접근성 이미지 검증 결과를 검색한다.
         * @param {string} [id] 
         * @param {AccessibilityTypeDTO} [accessibilityType] 
         * @param {InspectorTypeDTO} [inspectorType] 
         * @param {ResultTypeDTO} [resultType] 
         * @param {boolean} [isHandled] 
         * @param {number} [createdAtFrom] 검색 시작 시각 (epoch milliseconds, inclusive)
         * @param {number} [createdAtTo] 검색 종료 시각 (epoch milliseconds, exclusive)
         * @param {string} [cursor] 
         * @param {string} [limit] default 값은 20으로 설정된다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAccessibilityInspectionResults(id?: string, accessibilityType?: AccessibilityTypeDTO, inspectorType?: InspectorTypeDTO, resultType?: ResultTypeDTO, isHandled?: boolean, createdAtFrom?: number, createdAtTo?: number, cursor?: string, limit?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminSearchAccessibilityInspectionResultsDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchAccessibilityInspectionResults(id, accessibilityType, inspectorType, resultType, isHandled, createdAtFrom, createdAtTo, cursor, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 건물 정보를 업데이트한다.
         * @param {string} id 
         * @param {AdminUpdateBuildingAccessibilityRequestDTO} adminUpdateBuildingAccessibilityRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBuildingAccessibility(id: string, adminUpdateBuildingAccessibilityRequestDTO: AdminUpdateBuildingAccessibilityRequestDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBuildingAccessibility(id, adminUpdateBuildingAccessibilityRequestDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 장소 정보를 업데이트한다.
         * @param {string} id 
         * @param {AdminUpdatePlaceAccessibilityRequestDTO} adminUpdatePlaceAccessibilityRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePlaceAccessibility(id: string, adminUpdatePlaceAccessibilityRequestDTO: AdminUpdatePlaceAccessibilityRequestDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePlaceAccessibility(id, adminUpdatePlaceAccessibilityRequestDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccessibilityApi - factory interface
 * @export
 */
export const AccessibilityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessibilityApiFp(configuration)
    return {
        /**
         * 검수 결과 목록을 실제 접근성 정보에 일괄 반영합니다. - DELETE: 접근성 정보를 hard delete (관련 데이터 및 도메인 이벤트 포함) - MODIFY: PlaceAccessibility를 수정 요청에 따라 업데이트 - OK: 아무 작업도 하지 않음  이미 반영된 검수 결과(handledAt != null)는 중복 처리하지 않습니다. 각 검수 결과는 개별 트랜잭션으로 처리되어, 일부 실패해도 다른 결과는 계속 처리됩니다.  ## 두 가지 모드 지원: 1. **ID 기반 모드**: `inspectionResultIds` 배열을 제공하여 특정 검수 결과들을 반영 2. **필터 기반 모드**: `filter` 객체를 제공하여 조건에 맞는 모든 미처리 검수 결과를 반영  두 모드는 상호 배타적이며, 둘 중 하나만 제공해야 합니다. 
         * @summary 접근성 이미지 검증 결과를 일괄로 반영한다.
         * @param {ApplyAccessibilityInspectionResultsRequestDto} applyAccessibilityInspectionResultsRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyAccessibilityInspectionResults(applyAccessibilityInspectionResultsRequestDto: ApplyAccessibilityInspectionResultsRequestDto, options?: any): AxiosPromise<ApplyAccessibilityInspectionResultSummaryResponseDto> {
            return localVarFp.applyAccessibilityInspectionResults(applyAccessibilityInspectionResultsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Korean inspection sheet format (30 columns) CSV 파일을 업로드하여 인간 검수 결과를 일괄로 등록합니다. 100개 이하의 레코드는 동기 처리되며, 100개 초과시 비동기로 처리됩니다.  CSV 포맷: - 30개 컬럼의 한국어 검수 시트 형식 - Column 0: 장소 id (accessibilityId) - Column 15: 판정 (status: \"정상\"=PASS, \"삭제 대상\"=FAIL, \"수정 대상\"=MODIFY) - Column 16: (선택) 추가 의견 (comment) - Column 9: 코멘트 (reason - original comment) - Columns 20-25: Modification request (1층 여부, 층 수, 계단 개수, 계단 높이, 경사로 유무, 문 유형) - Column 29: 검수자 (inspector name) 
         * @summary CSV 파일을 업로드하여 인간 검수 결과를 일괄 등록한다.
         * @param {File} file CSV 파일
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkImportHumanInspections(file: File, options?: any): AxiosPromise<BulkImportHumanInspectionResponseDTO> {
            return localVarFp.bulkImportHumanInspections(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 건물 정보를 삭제한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuildingAccessibility(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteBuildingAccessibility(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 장소 정보를 삭제한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaceAccessibility(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePlaceAccessibility(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 접근성 정보의 이미지 파이프라인을 실행한다.
         * @param {RunAccessibilityImagePipelineRequest} runAccessibilityImagePipelineRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runAccessibilityImagePipeline(runAccessibilityImagePipelineRequest: RunAccessibilityImagePipelineRequest, options?: any): AxiosPromise<void> {
            return localVarFp.runAccessibilityImagePipeline(runAccessibilityImagePipelineRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 장소 & 건물 정보를 검색한다.
         * @param {string} [placeName] 
         * @param {string} [createdAtFromLocalDate] yyyy-MM-dd 형식
         * @param {string} [createdAtToLocalDate] yyyy-MM-dd 형식
         * @param {string} [cursor] 
         * @param {string} [limit] default 값은 20으로 설정된다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAccessibilities(placeName?: string, createdAtFromLocalDate?: string, createdAtToLocalDate?: string, cursor?: string, limit?: string, options?: any): AxiosPromise<AdminSearchAccessibilitiesResultDTO> {
            return localVarFp.searchAccessibilities(placeName, createdAtFromLocalDate, createdAtToLocalDate, cursor, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 접근성 이미지 검증 결과를 검색한다.
         * @param {string} [id] 
         * @param {AccessibilityTypeDTO} [accessibilityType] 
         * @param {InspectorTypeDTO} [inspectorType] 
         * @param {ResultTypeDTO} [resultType] 
         * @param {boolean} [isHandled] 
         * @param {number} [createdAtFrom] 검색 시작 시각 (epoch milliseconds, inclusive)
         * @param {number} [createdAtTo] 검색 종료 시각 (epoch milliseconds, exclusive)
         * @param {string} [cursor] 
         * @param {string} [limit] default 값은 20으로 설정된다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAccessibilityInspectionResults(id?: string, accessibilityType?: AccessibilityTypeDTO, inspectorType?: InspectorTypeDTO, resultType?: ResultTypeDTO, isHandled?: boolean, createdAtFrom?: number, createdAtTo?: number, cursor?: string, limit?: string, options?: any): AxiosPromise<AdminSearchAccessibilityInspectionResultsDTO> {
            return localVarFp.searchAccessibilityInspectionResults(id, accessibilityType, inspectorType, resultType, isHandled, createdAtFrom, createdAtTo, cursor, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 건물 정보를 업데이트한다.
         * @param {string} id 
         * @param {AdminUpdateBuildingAccessibilityRequestDTO} adminUpdateBuildingAccessibilityRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBuildingAccessibility(id: string, adminUpdateBuildingAccessibilityRequestDTO: AdminUpdateBuildingAccessibilityRequestDTO, options?: any): AxiosPromise<void> {
            return localVarFp.updateBuildingAccessibility(id, adminUpdateBuildingAccessibilityRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 장소 정보를 업데이트한다.
         * @param {string} id 
         * @param {AdminUpdatePlaceAccessibilityRequestDTO} adminUpdatePlaceAccessibilityRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlaceAccessibility(id: string, adminUpdatePlaceAccessibilityRequestDTO: AdminUpdatePlaceAccessibilityRequestDTO, options?: any): AxiosPromise<void> {
            return localVarFp.updatePlaceAccessibility(id, adminUpdatePlaceAccessibilityRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccessibilityApi - object-oriented interface
 * @export
 * @class AccessibilityApi
 * @extends {BaseAPI}
 */
export class AccessibilityApi extends BaseAPI {
    /**
     * 검수 결과 목록을 실제 접근성 정보에 일괄 반영합니다. - DELETE: 접근성 정보를 hard delete (관련 데이터 및 도메인 이벤트 포함) - MODIFY: PlaceAccessibility를 수정 요청에 따라 업데이트 - OK: 아무 작업도 하지 않음  이미 반영된 검수 결과(handledAt != null)는 중복 처리하지 않습니다. 각 검수 결과는 개별 트랜잭션으로 처리되어, 일부 실패해도 다른 결과는 계속 처리됩니다.  ## 두 가지 모드 지원: 1. **ID 기반 모드**: `inspectionResultIds` 배열을 제공하여 특정 검수 결과들을 반영 2. **필터 기반 모드**: `filter` 객체를 제공하여 조건에 맞는 모든 미처리 검수 결과를 반영  두 모드는 상호 배타적이며, 둘 중 하나만 제공해야 합니다. 
     * @summary 접근성 이미지 검증 결과를 일괄로 반영한다.
     * @param {ApplyAccessibilityInspectionResultsRequestDto} applyAccessibilityInspectionResultsRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessibilityApi
     */
    public applyAccessibilityInspectionResults(applyAccessibilityInspectionResultsRequestDto: ApplyAccessibilityInspectionResultsRequestDto, options?: AxiosRequestConfig) {
        return AccessibilityApiFp(this.configuration).applyAccessibilityInspectionResults(applyAccessibilityInspectionResultsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Korean inspection sheet format (30 columns) CSV 파일을 업로드하여 인간 검수 결과를 일괄로 등록합니다. 100개 이하의 레코드는 동기 처리되며, 100개 초과시 비동기로 처리됩니다.  CSV 포맷: - 30개 컬럼의 한국어 검수 시트 형식 - Column 0: 장소 id (accessibilityId) - Column 15: 판정 (status: \"정상\"=PASS, \"삭제 대상\"=FAIL, \"수정 대상\"=MODIFY) - Column 16: (선택) 추가 의견 (comment) - Column 9: 코멘트 (reason - original comment) - Columns 20-25: Modification request (1층 여부, 층 수, 계단 개수, 계단 높이, 경사로 유무, 문 유형) - Column 29: 검수자 (inspector name) 
     * @summary CSV 파일을 업로드하여 인간 검수 결과를 일괄 등록한다.
     * @param {File} file CSV 파일
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessibilityApi
     */
    public bulkImportHumanInspections(file: File, options?: AxiosRequestConfig) {
        return AccessibilityApiFp(this.configuration).bulkImportHumanInspections(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 건물 정보를 삭제한다.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessibilityApi
     */
    public deleteBuildingAccessibility(id: string, options?: AxiosRequestConfig) {
        return AccessibilityApiFp(this.configuration).deleteBuildingAccessibility(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 장소 정보를 삭제한다.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessibilityApi
     */
    public deletePlaceAccessibility(id: string, options?: AxiosRequestConfig) {
        return AccessibilityApiFp(this.configuration).deletePlaceAccessibility(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 접근성 정보의 이미지 파이프라인을 실행한다.
     * @param {RunAccessibilityImagePipelineRequest} runAccessibilityImagePipelineRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessibilityApi
     */
    public runAccessibilityImagePipeline(runAccessibilityImagePipelineRequest: RunAccessibilityImagePipelineRequest, options?: AxiosRequestConfig) {
        return AccessibilityApiFp(this.configuration).runAccessibilityImagePipeline(runAccessibilityImagePipelineRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 장소 & 건물 정보를 검색한다.
     * @param {string} [placeName] 
     * @param {string} [createdAtFromLocalDate] yyyy-MM-dd 형식
     * @param {string} [createdAtToLocalDate] yyyy-MM-dd 형식
     * @param {string} [cursor] 
     * @param {string} [limit] default 값은 20으로 설정된다.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessibilityApi
     */
    public searchAccessibilities(placeName?: string, createdAtFromLocalDate?: string, createdAtToLocalDate?: string, cursor?: string, limit?: string, options?: AxiosRequestConfig) {
        return AccessibilityApiFp(this.configuration).searchAccessibilities(placeName, createdAtFromLocalDate, createdAtToLocalDate, cursor, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 접근성 이미지 검증 결과를 검색한다.
     * @param {string} [id] 
     * @param {AccessibilityTypeDTO} [accessibilityType] 
     * @param {InspectorTypeDTO} [inspectorType] 
     * @param {ResultTypeDTO} [resultType] 
     * @param {boolean} [isHandled] 
     * @param {number} [createdAtFrom] 검색 시작 시각 (epoch milliseconds, inclusive)
     * @param {number} [createdAtTo] 검색 종료 시각 (epoch milliseconds, exclusive)
     * @param {string} [cursor] 
     * @param {string} [limit] default 값은 20으로 설정된다.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessibilityApi
     */
    public searchAccessibilityInspectionResults(id?: string, accessibilityType?: AccessibilityTypeDTO, inspectorType?: InspectorTypeDTO, resultType?: ResultTypeDTO, isHandled?: boolean, createdAtFrom?: number, createdAtTo?: number, cursor?: string, limit?: string, options?: AxiosRequestConfig) {
        return AccessibilityApiFp(this.configuration).searchAccessibilityInspectionResults(id, accessibilityType, inspectorType, resultType, isHandled, createdAtFrom, createdAtTo, cursor, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 건물 정보를 업데이트한다.
     * @param {string} id 
     * @param {AdminUpdateBuildingAccessibilityRequestDTO} adminUpdateBuildingAccessibilityRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessibilityApi
     */
    public updateBuildingAccessibility(id: string, adminUpdateBuildingAccessibilityRequestDTO: AdminUpdateBuildingAccessibilityRequestDTO, options?: AxiosRequestConfig) {
        return AccessibilityApiFp(this.configuration).updateBuildingAccessibility(id, adminUpdateBuildingAccessibilityRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 장소 정보를 업데이트한다.
     * @param {string} id 
     * @param {AdminUpdatePlaceAccessibilityRequestDTO} adminUpdatePlaceAccessibilityRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessibilityApi
     */
    public updatePlaceAccessibility(id: string, adminUpdatePlaceAccessibilityRequestDTO: AdminUpdatePlaceAccessibilityRequestDTO, options?: AxiosRequestConfig) {
        return AccessibilityApiFp(this.configuration).updatePlaceAccessibility(id, adminUpdatePlaceAccessibilityRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BannerApi - axios parameter creator
 * @export
 */
export const BannerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 전체 배너 목록을 조회한다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAllListBanners: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/banners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 배너를 생성한다.
         * @param {AdminCreateBannerRequestDTO} adminCreateBannerRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateBanner: async (adminCreateBannerRequestDTO: AdminCreateBannerRequestDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminCreateBannerRequestDTO' is not null or undefined
            assertParamExists('adminCreateBanner', 'adminCreateBannerRequestDTO', adminCreateBannerRequestDTO)
            const localVarPath = `/banners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminCreateBannerRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 배너를 삭제한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteBanner: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminDeleteBanner', 'id', id)
            const localVarPath = `/banners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 앱의 홈에 노출되는 것과 동일한 목록 & 순서의 배너를 보여준다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminListHomeBanners: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/banners/home-banner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BannerApi - functional programming interface
 * @export
 */
export const BannerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BannerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 전체 배너 목록을 조회한다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminAllListBanners(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminListAllBannersResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminAllListBanners(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 배너를 생성한다.
         * @param {AdminCreateBannerRequestDTO} adminCreateBannerRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCreateBanner(adminCreateBannerRequestDTO: AdminCreateBannerRequestDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCreateBanner(adminCreateBannerRequestDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 배너를 삭제한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDeleteBanner(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDeleteBanner(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 앱의 홈에 노출되는 것과 동일한 목록 & 순서의 배너를 보여준다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminListHomeBanners(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminListHomeBannersResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminListHomeBanners(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BannerApi - factory interface
 * @export
 */
export const BannerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BannerApiFp(configuration)
    return {
        /**
         * 
         * @summary 전체 배너 목록을 조회한다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAllListBanners(options?: any): AxiosPromise<AdminListAllBannersResponseDTO> {
            return localVarFp.adminAllListBanners(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 배너를 생성한다.
         * @param {AdminCreateBannerRequestDTO} adminCreateBannerRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateBanner(adminCreateBannerRequestDTO: AdminCreateBannerRequestDTO, options?: any): AxiosPromise<void> {
            return localVarFp.adminCreateBanner(adminCreateBannerRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 배너를 삭제한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteBanner(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.adminDeleteBanner(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 앱의 홈에 노출되는 것과 동일한 목록 & 순서의 배너를 보여준다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminListHomeBanners(options?: any): AxiosPromise<AdminListHomeBannersResponseDTO> {
            return localVarFp.adminListHomeBanners(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BannerApi - object-oriented interface
 * @export
 * @class BannerApi
 * @extends {BaseAPI}
 */
export class BannerApi extends BaseAPI {
    /**
     * 
     * @summary 전체 배너 목록을 조회한다.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannerApi
     */
    public adminAllListBanners(options?: AxiosRequestConfig) {
        return BannerApiFp(this.configuration).adminAllListBanners(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 배너를 생성한다.
     * @param {AdminCreateBannerRequestDTO} adminCreateBannerRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannerApi
     */
    public adminCreateBanner(adminCreateBannerRequestDTO: AdminCreateBannerRequestDTO, options?: AxiosRequestConfig) {
        return BannerApiFp(this.configuration).adminCreateBanner(adminCreateBannerRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 배너를 삭제한다.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannerApi
     */
    public adminDeleteBanner(id: string, options?: AxiosRequestConfig) {
        return BannerApiFp(this.configuration).adminDeleteBanner(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 앱의 홈에 노출되는 것과 동일한 목록 & 순서의 배너를 보여준다.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BannerApi
     */
    public adminListHomeBanners(options?: AxiosRequestConfig) {
        return BannerApiFp(this.configuration).adminListHomeBanners(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BbucleRoadApi - axios parameter creator
 * @export
 */
export const BbucleRoadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 뿌클로드 페이지를 생성한다.
         * @param {CreateBbucleRoadPageRequestDTO} createBbucleRoadPageRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBbucleRoadPage: async (createBbucleRoadPageRequestDTO: CreateBbucleRoadPageRequestDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createBbucleRoadPageRequestDTO' is not null or undefined
            assertParamExists('createBbucleRoadPage', 'createBbucleRoadPageRequestDTO', createBbucleRoadPageRequestDTO)
            const localVarPath = `/bbucle-road-pages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBbucleRoadPageRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 뿌클로드 페이지를 삭제한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBbucleRoadPage: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteBbucleRoadPage', 'id', id)
            const localVarPath = `/bbucle-road-pages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 뿌클로드 페이지를 조회한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBbucleRoadPage: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBbucleRoadPage', 'id', id)
            const localVarPath = `/bbucle-road-pages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 뿌클로드 페이지 목록을 조회한다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBbucleRoadPages: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bbucle-road-pages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 뿌클로드 페이지를 수정한다.
         * @param {string} id 
         * @param {UpdateBbucleRoadPageRequestDTO} updateBbucleRoadPageRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBbucleRoadPage: async (id: string, updateBbucleRoadPageRequestDTO: UpdateBbucleRoadPageRequestDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateBbucleRoadPage', 'id', id)
            // verify required parameter 'updateBbucleRoadPageRequestDTO' is not null or undefined
            assertParamExists('updateBbucleRoadPage', 'updateBbucleRoadPageRequestDTO', updateBbucleRoadPageRequestDTO)
            const localVarPath = `/bbucle-road-pages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateBbucleRoadPageRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BbucleRoadApi - functional programming interface
 * @export
 */
export const BbucleRoadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BbucleRoadApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 뿌클로드 페이지를 생성한다.
         * @param {CreateBbucleRoadPageRequestDTO} createBbucleRoadPageRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBbucleRoadPage(createBbucleRoadPageRequestDTO: CreateBbucleRoadPageRequestDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BbucleRoadPageDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBbucleRoadPage(createBbucleRoadPageRequestDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 뿌클로드 페이지를 삭제한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBbucleRoadPage(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBbucleRoadPage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 뿌클로드 페이지를 조회한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBbucleRoadPage(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BbucleRoadPageDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBbucleRoadPage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 뿌클로드 페이지 목록을 조회한다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBbucleRoadPages(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BbucleRoadPageDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBbucleRoadPages(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 뿌클로드 페이지를 수정한다.
         * @param {string} id 
         * @param {UpdateBbucleRoadPageRequestDTO} updateBbucleRoadPageRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBbucleRoadPage(id: string, updateBbucleRoadPageRequestDTO: UpdateBbucleRoadPageRequestDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BbucleRoadPageDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBbucleRoadPage(id, updateBbucleRoadPageRequestDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BbucleRoadApi - factory interface
 * @export
 */
export const BbucleRoadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BbucleRoadApiFp(configuration)
    return {
        /**
         * 
         * @summary 뿌클로드 페이지를 생성한다.
         * @param {CreateBbucleRoadPageRequestDTO} createBbucleRoadPageRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBbucleRoadPage(createBbucleRoadPageRequestDTO: CreateBbucleRoadPageRequestDTO, options?: any): AxiosPromise<BbucleRoadPageDTO> {
            return localVarFp.createBbucleRoadPage(createBbucleRoadPageRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 뿌클로드 페이지를 삭제한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBbucleRoadPage(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteBbucleRoadPage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 뿌클로드 페이지를 조회한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBbucleRoadPage(id: string, options?: any): AxiosPromise<BbucleRoadPageDTO> {
            return localVarFp.getBbucleRoadPage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 뿌클로드 페이지 목록을 조회한다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBbucleRoadPages(options?: any): AxiosPromise<Array<BbucleRoadPageDTO>> {
            return localVarFp.listBbucleRoadPages(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 뿌클로드 페이지를 수정한다.
         * @param {string} id 
         * @param {UpdateBbucleRoadPageRequestDTO} updateBbucleRoadPageRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBbucleRoadPage(id: string, updateBbucleRoadPageRequestDTO: UpdateBbucleRoadPageRequestDTO, options?: any): AxiosPromise<BbucleRoadPageDTO> {
            return localVarFp.updateBbucleRoadPage(id, updateBbucleRoadPageRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BbucleRoadApi - object-oriented interface
 * @export
 * @class BbucleRoadApi
 * @extends {BaseAPI}
 */
export class BbucleRoadApi extends BaseAPI {
    /**
     * 
     * @summary 뿌클로드 페이지를 생성한다.
     * @param {CreateBbucleRoadPageRequestDTO} createBbucleRoadPageRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BbucleRoadApi
     */
    public createBbucleRoadPage(createBbucleRoadPageRequestDTO: CreateBbucleRoadPageRequestDTO, options?: AxiosRequestConfig) {
        return BbucleRoadApiFp(this.configuration).createBbucleRoadPage(createBbucleRoadPageRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 뿌클로드 페이지를 삭제한다.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BbucleRoadApi
     */
    public deleteBbucleRoadPage(id: string, options?: AxiosRequestConfig) {
        return BbucleRoadApiFp(this.configuration).deleteBbucleRoadPage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 뿌클로드 페이지를 조회한다.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BbucleRoadApi
     */
    public getBbucleRoadPage(id: string, options?: AxiosRequestConfig) {
        return BbucleRoadApiFp(this.configuration).getBbucleRoadPage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 뿌클로드 페이지 목록을 조회한다.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BbucleRoadApi
     */
    public listBbucleRoadPages(options?: AxiosRequestConfig) {
        return BbucleRoadApiFp(this.configuration).listBbucleRoadPages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 뿌클로드 페이지를 수정한다.
     * @param {string} id 
     * @param {UpdateBbucleRoadPageRequestDTO} updateBbucleRoadPageRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BbucleRoadApi
     */
    public updateBbucleRoadPage(id: string, updateBbucleRoadPageRequestDTO: UpdateBbucleRoadPageRequestDTO, options?: AxiosRequestConfig) {
        return BbucleRoadApiFp(this.configuration).updateBbucleRoadPage(id, updateBbucleRoadPageRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BuildingDivisionApi - axios parameter creator
 * @export
 */
export const BuildingDivisionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Building Division의 Place들을 SubBuilding에 할당한다.
         * @param {string} divisionId Building Division ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignPlacesToSubBuildings: async (divisionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'divisionId' is not null or undefined
            assertParamExists('assignPlacesToSubBuildings', 'divisionId', divisionId)
            const localVarPath = `/building-divisions/{divisionId}/assign-places-to-sub-buildings`
                .replace(`{${"divisionId"}}`, encodeURIComponent(String(divisionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Building Division을 확정한다.
         * @param {string} divisionId Building Division ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmBuildingDivision: async (divisionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'divisionId' is not null or undefined
            assertParamExists('confirmBuildingDivision', 'divisionId', divisionId)
            const localVarPath = `/building-divisions/{divisionId}/confirm`
                .replace(`{${"divisionId"}}`, encodeURIComponent(String(divisionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 새로운 Building Division을 생성한다.
         * @param {AdminCreateBuildingDivisionRequestDTO} adminCreateBuildingDivisionRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuildingDivision: async (adminCreateBuildingDivisionRequestDTO: AdminCreateBuildingDivisionRequestDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminCreateBuildingDivisionRequestDTO' is not null or undefined
            assertParamExists('createBuildingDivision', 'adminCreateBuildingDivisionRequestDTO', adminCreateBuildingDivisionRequestDTO)
            const localVarPath = `/building-divisions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminCreateBuildingDivisionRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Building Division에 SubBuilding을 추가한다.
         * @param {string} divisionId Building Division ID
         * @param {AdminCreateSubBuildingRequestDTO} adminCreateSubBuildingRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubBuilding: async (divisionId: string, adminCreateSubBuildingRequestDTO: AdminCreateSubBuildingRequestDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'divisionId' is not null or undefined
            assertParamExists('createSubBuilding', 'divisionId', divisionId)
            // verify required parameter 'adminCreateSubBuildingRequestDTO' is not null or undefined
            assertParamExists('createSubBuilding', 'adminCreateSubBuildingRequestDTO', adminCreateSubBuildingRequestDTO)
            const localVarPath = `/building-divisions/{divisionId}/sub-buildings`
                .replace(`{${"divisionId"}}`, encodeURIComponent(String(divisionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminCreateSubBuildingRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary SubBuilding을 삭제한다.
         * @param {string} divisionId Building Division ID
         * @param {string} subBuildingId SubBuilding ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubBuilding: async (divisionId: string, subBuildingId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'divisionId' is not null or undefined
            assertParamExists('deleteSubBuilding', 'divisionId', divisionId)
            // verify required parameter 'subBuildingId' is not null or undefined
            assertParamExists('deleteSubBuilding', 'subBuildingId', subBuildingId)
            const localVarPath = `/building-divisions/{divisionId}/sub-buildings/{subBuildingId}`
                .replace(`{${"divisionId"}}`, encodeURIComponent(String(divisionId)))
                .replace(`{${"subBuildingId"}}`, encodeURIComponent(String(subBuildingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Building Division 상세 정보를 조회한다.
         * @param {string} divisionId Building Division ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuildingDivision: async (divisionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'divisionId' is not null or undefined
            assertParamExists('getBuildingDivision', 'divisionId', divisionId)
            const localVarPath = `/building-divisions/{divisionId}`
                .replace(`{${"divisionId"}}`, encodeURIComponent(String(divisionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Building Division을 무시한다.
         * @param {string} divisionId Building Division ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ignoreBuildingDivision: async (divisionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'divisionId' is not null or undefined
            assertParamExists('ignoreBuildingDivision', 'divisionId', divisionId)
            const localVarPath = `/building-divisions/{divisionId}/ignore`
                .replace(`{${"divisionId"}}`, encodeURIComponent(String(divisionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Building Division 목록을 조회한다.
         * @param {AdminBuildingDivisionStatusDTO} [status] 상태별 필터링 (미지정시 전체)
         * @param {number} [limit] 페이지당 항목 수 (기본값 20)
         * @param {string} [cursor] 커서 페이지네이션용 커서 값
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuildingDivisions: async (status?: AdminBuildingDivisionStatusDTO, limit?: number, cursor?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/building-divisions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary SubBuilding 정보를 수정한다.
         * @param {string} divisionId Building Division ID
         * @param {string} subBuildingId SubBuilding ID
         * @param {AdminUpdateSubBuildingRequestDTO} adminUpdateSubBuildingRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubBuilding: async (divisionId: string, subBuildingId: string, adminUpdateSubBuildingRequestDTO: AdminUpdateSubBuildingRequestDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'divisionId' is not null or undefined
            assertParamExists('updateSubBuilding', 'divisionId', divisionId)
            // verify required parameter 'subBuildingId' is not null or undefined
            assertParamExists('updateSubBuilding', 'subBuildingId', subBuildingId)
            // verify required parameter 'adminUpdateSubBuildingRequestDTO' is not null or undefined
            assertParamExists('updateSubBuilding', 'adminUpdateSubBuildingRequestDTO', adminUpdateSubBuildingRequestDTO)
            const localVarPath = `/building-divisions/{divisionId}/sub-buildings/{subBuildingId}`
                .replace(`{${"divisionId"}}`, encodeURIComponent(String(divisionId)))
                .replace(`{${"subBuildingId"}}`, encodeURIComponent(String(subBuildingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminUpdateSubBuildingRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BuildingDivisionApi - functional programming interface
 * @export
 */
export const BuildingDivisionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BuildingDivisionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Building Division의 Place들을 SubBuilding에 할당한다.
         * @param {string} divisionId Building Division ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignPlacesToSubBuildings(divisionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminAssignPlacesToSubBuildingsResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignPlacesToSubBuildings(divisionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Building Division을 확정한다.
         * @param {string} divisionId Building Division ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmBuildingDivision(divisionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminBuildingDivisionDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmBuildingDivision(divisionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 새로운 Building Division을 생성한다.
         * @param {AdminCreateBuildingDivisionRequestDTO} adminCreateBuildingDivisionRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBuildingDivision(adminCreateBuildingDivisionRequestDTO: AdminCreateBuildingDivisionRequestDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminBuildingDivisionDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBuildingDivision(adminCreateBuildingDivisionRequestDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Building Division에 SubBuilding을 추가한다.
         * @param {string} divisionId Building Division ID
         * @param {AdminCreateSubBuildingRequestDTO} adminCreateSubBuildingRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubBuilding(divisionId: string, adminCreateSubBuildingRequestDTO: AdminCreateSubBuildingRequestDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminSubBuildingDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubBuilding(divisionId, adminCreateSubBuildingRequestDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary SubBuilding을 삭제한다.
         * @param {string} divisionId Building Division ID
         * @param {string} subBuildingId SubBuilding ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSubBuilding(divisionId: string, subBuildingId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSubBuilding(divisionId, subBuildingId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Building Division 상세 정보를 조회한다.
         * @param {string} divisionId Building Division ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBuildingDivision(divisionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminBuildingDivisionDetailDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildingDivision(divisionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Building Division을 무시한다.
         * @param {string} divisionId Building Division ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ignoreBuildingDivision(divisionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminBuildingDivisionDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ignoreBuildingDivision(divisionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Building Division 목록을 조회한다.
         * @param {AdminBuildingDivisionStatusDTO} [status] 상태별 필터링 (미지정시 전체)
         * @param {number} [limit] 페이지당 항목 수 (기본값 20)
         * @param {string} [cursor] 커서 페이지네이션용 커서 값
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBuildingDivisions(status?: AdminBuildingDivisionStatusDTO, limit?: number, cursor?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminListBuildingDivisionsResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBuildingDivisions(status, limit, cursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary SubBuilding 정보를 수정한다.
         * @param {string} divisionId Building Division ID
         * @param {string} subBuildingId SubBuilding ID
         * @param {AdminUpdateSubBuildingRequestDTO} adminUpdateSubBuildingRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSubBuilding(divisionId: string, subBuildingId: string, adminUpdateSubBuildingRequestDTO: AdminUpdateSubBuildingRequestDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminSubBuildingDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSubBuilding(divisionId, subBuildingId, adminUpdateSubBuildingRequestDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BuildingDivisionApi - factory interface
 * @export
 */
export const BuildingDivisionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BuildingDivisionApiFp(configuration)
    return {
        /**
         * 
         * @summary Building Division의 Place들을 SubBuilding에 할당한다.
         * @param {string} divisionId Building Division ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignPlacesToSubBuildings(divisionId: string, options?: any): AxiosPromise<AdminAssignPlacesToSubBuildingsResponseDTO> {
            return localVarFp.assignPlacesToSubBuildings(divisionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Building Division을 확정한다.
         * @param {string} divisionId Building Division ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmBuildingDivision(divisionId: string, options?: any): AxiosPromise<AdminBuildingDivisionDTO> {
            return localVarFp.confirmBuildingDivision(divisionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 새로운 Building Division을 생성한다.
         * @param {AdminCreateBuildingDivisionRequestDTO} adminCreateBuildingDivisionRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBuildingDivision(adminCreateBuildingDivisionRequestDTO: AdminCreateBuildingDivisionRequestDTO, options?: any): AxiosPromise<AdminBuildingDivisionDTO> {
            return localVarFp.createBuildingDivision(adminCreateBuildingDivisionRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Building Division에 SubBuilding을 추가한다.
         * @param {string} divisionId Building Division ID
         * @param {AdminCreateSubBuildingRequestDTO} adminCreateSubBuildingRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubBuilding(divisionId: string, adminCreateSubBuildingRequestDTO: AdminCreateSubBuildingRequestDTO, options?: any): AxiosPromise<AdminSubBuildingDTO> {
            return localVarFp.createSubBuilding(divisionId, adminCreateSubBuildingRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary SubBuilding을 삭제한다.
         * @param {string} divisionId Building Division ID
         * @param {string} subBuildingId SubBuilding ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubBuilding(divisionId: string, subBuildingId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSubBuilding(divisionId, subBuildingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Building Division 상세 정보를 조회한다.
         * @param {string} divisionId Building Division ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuildingDivision(divisionId: string, options?: any): AxiosPromise<AdminBuildingDivisionDetailDTO> {
            return localVarFp.getBuildingDivision(divisionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Building Division을 무시한다.
         * @param {string} divisionId Building Division ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ignoreBuildingDivision(divisionId: string, options?: any): AxiosPromise<AdminBuildingDivisionDTO> {
            return localVarFp.ignoreBuildingDivision(divisionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Building Division 목록을 조회한다.
         * @param {AdminBuildingDivisionStatusDTO} [status] 상태별 필터링 (미지정시 전체)
         * @param {number} [limit] 페이지당 항목 수 (기본값 20)
         * @param {string} [cursor] 커서 페이지네이션용 커서 값
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBuildingDivisions(status?: AdminBuildingDivisionStatusDTO, limit?: number, cursor?: string, options?: any): AxiosPromise<AdminListBuildingDivisionsResponseDTO> {
            return localVarFp.listBuildingDivisions(status, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary SubBuilding 정보를 수정한다.
         * @param {string} divisionId Building Division ID
         * @param {string} subBuildingId SubBuilding ID
         * @param {AdminUpdateSubBuildingRequestDTO} adminUpdateSubBuildingRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubBuilding(divisionId: string, subBuildingId: string, adminUpdateSubBuildingRequestDTO: AdminUpdateSubBuildingRequestDTO, options?: any): AxiosPromise<AdminSubBuildingDTO> {
            return localVarFp.updateSubBuilding(divisionId, subBuildingId, adminUpdateSubBuildingRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BuildingDivisionApi - object-oriented interface
 * @export
 * @class BuildingDivisionApi
 * @extends {BaseAPI}
 */
export class BuildingDivisionApi extends BaseAPI {
    /**
     * 
     * @summary Building Division의 Place들을 SubBuilding에 할당한다.
     * @param {string} divisionId Building Division ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildingDivisionApi
     */
    public assignPlacesToSubBuildings(divisionId: string, options?: AxiosRequestConfig) {
        return BuildingDivisionApiFp(this.configuration).assignPlacesToSubBuildings(divisionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Building Division을 확정한다.
     * @param {string} divisionId Building Division ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildingDivisionApi
     */
    public confirmBuildingDivision(divisionId: string, options?: AxiosRequestConfig) {
        return BuildingDivisionApiFp(this.configuration).confirmBuildingDivision(divisionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 새로운 Building Division을 생성한다.
     * @param {AdminCreateBuildingDivisionRequestDTO} adminCreateBuildingDivisionRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildingDivisionApi
     */
    public createBuildingDivision(adminCreateBuildingDivisionRequestDTO: AdminCreateBuildingDivisionRequestDTO, options?: AxiosRequestConfig) {
        return BuildingDivisionApiFp(this.configuration).createBuildingDivision(adminCreateBuildingDivisionRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Building Division에 SubBuilding을 추가한다.
     * @param {string} divisionId Building Division ID
     * @param {AdminCreateSubBuildingRequestDTO} adminCreateSubBuildingRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildingDivisionApi
     */
    public createSubBuilding(divisionId: string, adminCreateSubBuildingRequestDTO: AdminCreateSubBuildingRequestDTO, options?: AxiosRequestConfig) {
        return BuildingDivisionApiFp(this.configuration).createSubBuilding(divisionId, adminCreateSubBuildingRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary SubBuilding을 삭제한다.
     * @param {string} divisionId Building Division ID
     * @param {string} subBuildingId SubBuilding ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildingDivisionApi
     */
    public deleteSubBuilding(divisionId: string, subBuildingId: string, options?: AxiosRequestConfig) {
        return BuildingDivisionApiFp(this.configuration).deleteSubBuilding(divisionId, subBuildingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Building Division 상세 정보를 조회한다.
     * @param {string} divisionId Building Division ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildingDivisionApi
     */
    public getBuildingDivision(divisionId: string, options?: AxiosRequestConfig) {
        return BuildingDivisionApiFp(this.configuration).getBuildingDivision(divisionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Building Division을 무시한다.
     * @param {string} divisionId Building Division ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildingDivisionApi
     */
    public ignoreBuildingDivision(divisionId: string, options?: AxiosRequestConfig) {
        return BuildingDivisionApiFp(this.configuration).ignoreBuildingDivision(divisionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Building Division 목록을 조회한다.
     * @param {AdminBuildingDivisionStatusDTO} [status] 상태별 필터링 (미지정시 전체)
     * @param {number} [limit] 페이지당 항목 수 (기본값 20)
     * @param {string} [cursor] 커서 페이지네이션용 커서 값
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildingDivisionApi
     */
    public listBuildingDivisions(status?: AdminBuildingDivisionStatusDTO, limit?: number, cursor?: string, options?: AxiosRequestConfig) {
        return BuildingDivisionApiFp(this.configuration).listBuildingDivisions(status, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary SubBuilding 정보를 수정한다.
     * @param {string} divisionId Building Division ID
     * @param {string} subBuildingId SubBuilding ID
     * @param {AdminUpdateSubBuildingRequestDTO} adminUpdateSubBuildingRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildingDivisionApi
     */
    public updateSubBuilding(divisionId: string, subBuildingId: string, adminUpdateSubBuildingRequestDTO: AdminUpdateSubBuildingRequestDTO, options?: AxiosRequestConfig) {
        return BuildingDivisionApiFp(this.configuration).updateSubBuilding(divisionId, subBuildingId, adminUpdateSubBuildingRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ChallengeApi - axios parameter creator
 * @export
 */
export const ChallengeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 챌린지를 삭제한다.
         * @param {string} challengeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        challengesChallengeIdDelete: async (challengeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'challengeId' is not null or undefined
            assertParamExists('challengesChallengeIdDelete', 'challengeId', challengeId)
            const localVarPath = `/challenges/{challengeId}`
                .replace(`{${"challengeId"}}`, encodeURIComponent(String(challengeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 챌린지를 조회한다.
         * @param {string} challengeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        challengesChallengeIdGet: async (challengeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'challengeId' is not null or undefined
            assertParamExists('challengesChallengeIdGet', 'challengeId', challengeId)
            const localVarPath = `/challenges/{challengeId}`
                .replace(`{${"challengeId"}}`, encodeURIComponent(String(challengeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 챌린지를 업데이트한다.
         * @param {string} challengeId 
         * @param {AdminUpdateChallengeRequestDTO} adminUpdateChallengeRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        challengesChallengeIdPut: async (challengeId: string, adminUpdateChallengeRequestDTO: AdminUpdateChallengeRequestDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'challengeId' is not null or undefined
            assertParamExists('challengesChallengeIdPut', 'challengeId', challengeId)
            // verify required parameter 'adminUpdateChallengeRequestDTO' is not null or undefined
            assertParamExists('challengesChallengeIdPut', 'adminUpdateChallengeRequestDTO', adminUpdateChallengeRequestDTO)
            const localVarPath = `/challenges/{challengeId}`
                .replace(`{${"challengeId"}}`, encodeURIComponent(String(challengeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminUpdateChallengeRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 챌린지 목록을 조회한다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        challengesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/challenges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 챌린지를 생성한다.
         * @param {AdminCreateChallengeRequestDTO} adminCreateChallengeRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        challengesPost: async (adminCreateChallengeRequestDTO: AdminCreateChallengeRequestDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminCreateChallengeRequestDTO' is not null or undefined
            assertParamExists('challengesPost', 'adminCreateChallengeRequestDTO', adminCreateChallengeRequestDTO)
            const localVarPath = `/challenges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminCreateChallengeRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChallengeApi - functional programming interface
 * @export
 */
export const ChallengeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChallengeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 챌린지를 삭제한다.
         * @param {string} challengeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async challengesChallengeIdDelete(challengeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.challengesChallengeIdDelete(challengeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 챌린지를 조회한다.
         * @param {string} challengeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async challengesChallengeIdGet(challengeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminChallengeDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.challengesChallengeIdGet(challengeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 챌린지를 업데이트한다.
         * @param {string} challengeId 
         * @param {AdminUpdateChallengeRequestDTO} adminUpdateChallengeRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async challengesChallengeIdPut(challengeId: string, adminUpdateChallengeRequestDTO: AdminUpdateChallengeRequestDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.challengesChallengeIdPut(challengeId, adminUpdateChallengeRequestDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 챌린지 목록을 조회한다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async challengesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AdminChallengeDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.challengesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 챌린지를 생성한다.
         * @param {AdminCreateChallengeRequestDTO} adminCreateChallengeRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async challengesPost(adminCreateChallengeRequestDTO: AdminCreateChallengeRequestDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.challengesPost(adminCreateChallengeRequestDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ChallengeApi - factory interface
 * @export
 */
export const ChallengeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChallengeApiFp(configuration)
    return {
        /**
         * 
         * @summary 챌린지를 삭제한다.
         * @param {string} challengeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        challengesChallengeIdDelete(challengeId: string, options?: any): AxiosPromise<void> {
            return localVarFp.challengesChallengeIdDelete(challengeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 챌린지를 조회한다.
         * @param {string} challengeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        challengesChallengeIdGet(challengeId: string, options?: any): AxiosPromise<AdminChallengeDTO> {
            return localVarFp.challengesChallengeIdGet(challengeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 챌린지를 업데이트한다.
         * @param {string} challengeId 
         * @param {AdminUpdateChallengeRequestDTO} adminUpdateChallengeRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        challengesChallengeIdPut(challengeId: string, adminUpdateChallengeRequestDTO: AdminUpdateChallengeRequestDTO, options?: any): AxiosPromise<void> {
            return localVarFp.challengesChallengeIdPut(challengeId, adminUpdateChallengeRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 챌린지 목록을 조회한다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        challengesGet(options?: any): AxiosPromise<Array<AdminChallengeDTO>> {
            return localVarFp.challengesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 챌린지를 생성한다.
         * @param {AdminCreateChallengeRequestDTO} adminCreateChallengeRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        challengesPost(adminCreateChallengeRequestDTO: AdminCreateChallengeRequestDTO, options?: any): AxiosPromise<void> {
            return localVarFp.challengesPost(adminCreateChallengeRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChallengeApi - object-oriented interface
 * @export
 * @class ChallengeApi
 * @extends {BaseAPI}
 */
export class ChallengeApi extends BaseAPI {
    /**
     * 
     * @summary 챌린지를 삭제한다.
     * @param {string} challengeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengeApi
     */
    public challengesChallengeIdDelete(challengeId: string, options?: AxiosRequestConfig) {
        return ChallengeApiFp(this.configuration).challengesChallengeIdDelete(challengeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 챌린지를 조회한다.
     * @param {string} challengeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengeApi
     */
    public challengesChallengeIdGet(challengeId: string, options?: AxiosRequestConfig) {
        return ChallengeApiFp(this.configuration).challengesChallengeIdGet(challengeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 챌린지를 업데이트한다.
     * @param {string} challengeId 
     * @param {AdminUpdateChallengeRequestDTO} adminUpdateChallengeRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengeApi
     */
    public challengesChallengeIdPut(challengeId: string, adminUpdateChallengeRequestDTO: AdminUpdateChallengeRequestDTO, options?: AxiosRequestConfig) {
        return ChallengeApiFp(this.configuration).challengesChallengeIdPut(challengeId, adminUpdateChallengeRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 챌린지 목록을 조회한다.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengeApi
     */
    public challengesGet(options?: AxiosRequestConfig) {
        return ChallengeApiFp(this.configuration).challengesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 챌린지를 생성한다.
     * @param {AdminCreateChallengeRequestDTO} adminCreateChallengeRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengeApi
     */
    public challengesPost(adminCreateChallengeRequestDTO: AdminCreateChallengeRequestDTO, options?: AxiosRequestConfig) {
        return ChallengeApiFp(this.configuration).challengesPost(adminCreateChallengeRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 해당 장소를 폐업 상태로 변경한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptClosedPlaceCandidate: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('acceptClosedPlaceCandidate', 'id', id)
            const localVarPath = `/closed-place-candidates/{id}/accept`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 정보 등록 가능 지역 목록을 조회한다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessibilityAllowedRegionsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accessibilityAllowedRegions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 정보 등록 가능 지역을 생성한다.
         * @param {CreateAccessibilityAllowedRegionRequestDTO} createAccessibilityAllowedRegionRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessibilityAllowedRegionsPost: async (createAccessibilityAllowedRegionRequestDTO: CreateAccessibilityAllowedRegionRequestDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAccessibilityAllowedRegionRequestDTO' is not null or undefined
            assertParamExists('accessibilityAllowedRegionsPost', 'createAccessibilityAllowedRegionRequestDTO', createAccessibilityAllowedRegionRequestDTO)
            const localVarPath = `/accessibilityAllowedRegions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAccessibilityAllowedRegionRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 정보 등록 가능 지역을 삭제한다.
         * @param {string} regionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessibilityAllowedRegionsRegionIdDelete: async (regionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionId' is not null or undefined
            assertParamExists('accessibilityAllowedRegionsRegionIdDelete', 'regionId', regionId)
            const localVarPath = `/accessibilityAllowedRegions/{regionId}`
                .replace(`{${"regionId"}}`, encodeURIComponent(String(regionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 정보 등록 가능 지역을 조회한다.
         * @param {string} regionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessibilityAllowedRegionsRegionIdGet: async (regionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionId' is not null or undefined
            assertParamExists('accessibilityAllowedRegionsRegionIdGet', 'regionId', regionId)
            const localVarPath = `/accessibilityAllowedRegions/{regionId}`
                .replace(`{${"regionId"}}`, encodeURIComponent(String(regionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 배너 생성 등의 상황에서 이미지를 업로드하기 위한 URL을 받아 온다.
         * @param {AdminCreateImageUploadUrlsRequestDTO} adminCreateImageUploadUrlsRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateImageUploadUrls: async (adminCreateImageUploadUrlsRequestDTO: AdminCreateImageUploadUrlsRequestDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminCreateImageUploadUrlsRequestDTO' is not null or undefined
            assertParamExists('adminCreateImageUploadUrls', 'adminCreateImageUploadUrlsRequestDTO', adminCreateImageUploadUrlsRequestDTO)
            const localVarPath = `/image-upload-urls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminCreateImageUploadUrlsRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 푸시 알림 스케쥴을 커서링 방식으로 조회한다.
         * @summary 커서링 방식의 푸시 알림 조회.
         * @param {string} [cursor] 
         * @param {string} [limit] default 값은 50으로 설정된다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetPushSchedules: async (cursor?: string, limit?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notifications/pushSchedules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 유저들에게 push notification을 보낸다.
         * @param {AdminSendPushNotificationRequestDTO} adminSendPushNotificationRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminSendPushNotification: async (adminSendPushNotificationRequestDTO: AdminSendPushNotificationRequestDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminSendPushNotificationRequestDTO' is not null or undefined
            assertParamExists('adminSendPushNotification', 'adminSendPushNotificationRequestDTO', adminSendPushNotificationRequestDTO)
            const localVarPath = `/notifications/sendPush`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminSendPushNotificationRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 퀘스트를 삭제한다.
         * @param {string} clubQuestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubQuestsClubQuestIdDelete: async (clubQuestId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clubQuestId' is not null or undefined
            assertParamExists('clubQuestsClubQuestIdDelete', 'clubQuestId', clubQuestId)
            const localVarPath = `/clubQuests/{clubQuestId}`
                .replace(`{${"clubQuestId"}}`, encodeURIComponent(String(clubQuestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 퀘스트를 조회한다.
         * @param {string} clubQuestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubQuestsClubQuestIdGet: async (clubQuestId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clubQuestId' is not null or undefined
            assertParamExists('clubQuestsClubQuestIdGet', 'clubQuestId', clubQuestId)
            const localVarPath = `/clubQuests/{clubQuestId}`
                .replace(`{${"clubQuestId"}}`, encodeURIComponent(String(clubQuestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 점포의 폐점 여부를 저장한다.
         * @param {string} clubQuestId 
         * @param {ClubQuestsClubQuestIdIsClosedPutRequest} clubQuestsClubQuestIdIsClosedPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubQuestsClubQuestIdIsClosedPut: async (clubQuestId: string, clubQuestsClubQuestIdIsClosedPutRequest: ClubQuestsClubQuestIdIsClosedPutRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clubQuestId' is not null or undefined
            assertParamExists('clubQuestsClubQuestIdIsClosedPut', 'clubQuestId', clubQuestId)
            // verify required parameter 'clubQuestsClubQuestIdIsClosedPutRequest' is not null or undefined
            assertParamExists('clubQuestsClubQuestIdIsClosedPut', 'clubQuestsClubQuestIdIsClosedPutRequest', clubQuestsClubQuestIdIsClosedPutRequest)
            const localVarPath = `/clubQuests/{clubQuestId}/isClosed`
                .replace(`{${"clubQuestId"}}`, encodeURIComponent(String(clubQuestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clubQuestsClubQuestIdIsClosedPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 점포의 접근 가능 여부를 저장한다.
         * @param {string} clubQuestId 
         * @param {ClubQuestsClubQuestIdIsNotAccessiblePutRequest} clubQuestsClubQuestIdIsNotAccessiblePutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubQuestsClubQuestIdIsNotAccessiblePut: async (clubQuestId: string, clubQuestsClubQuestIdIsNotAccessiblePutRequest: ClubQuestsClubQuestIdIsNotAccessiblePutRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clubQuestId' is not null or undefined
            assertParamExists('clubQuestsClubQuestIdIsNotAccessiblePut', 'clubQuestId', clubQuestId)
            // verify required parameter 'clubQuestsClubQuestIdIsNotAccessiblePutRequest' is not null or undefined
            assertParamExists('clubQuestsClubQuestIdIsNotAccessiblePut', 'clubQuestsClubQuestIdIsNotAccessiblePutRequest', clubQuestsClubQuestIdIsNotAccessiblePutRequest)
            const localVarPath = `/clubQuests/{clubQuestId}/isNotAccessible`
                .replace(`{${"clubQuestId"}}`, encodeURIComponent(String(clubQuestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clubQuestsClubQuestIdIsNotAccessiblePutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 퀘스트에서 특정 건물을 제외한다.
         * @param {string} clubQuestId 
         * @param {string} buildingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubQuestsClubQuestIdTargetBuildingsDelete: async (clubQuestId: string, buildingId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clubQuestId' is not null or undefined
            assertParamExists('clubQuestsClubQuestIdTargetBuildingsDelete', 'clubQuestId', clubQuestId)
            // verify required parameter 'buildingId' is not null or undefined
            assertParamExists('clubQuestsClubQuestIdTargetBuildingsDelete', 'buildingId', buildingId)
            const localVarPath = `/clubQuests/{clubQuestId}/targetBuildings`
                .replace(`{${"clubQuestId"}}`, encodeURIComponent(String(clubQuestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (buildingId !== undefined) {
                localVarQueryParameter['buildingId'] = buildingId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 퀘스트에서 특정 장소를 제외한다.
         * @param {string} clubQuestId 
         * @param {string} placeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubQuestsClubQuestIdTargetPlacesDelete: async (clubQuestId: string, placeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clubQuestId' is not null or undefined
            assertParamExists('clubQuestsClubQuestIdTargetPlacesDelete', 'clubQuestId', clubQuestId)
            // verify required parameter 'placeId' is not null or undefined
            assertParamExists('clubQuestsClubQuestIdTargetPlacesDelete', 'placeId', placeId)
            const localVarPath = `/clubQuests/{clubQuestId}/targetPlaces`
                .replace(`{${"clubQuestId"}}`, encodeURIComponent(String(clubQuestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (placeId !== undefined) {
                localVarQueryParameter['placeId'] = placeId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 주어진 조건(중심 위치, 반경, 퀘스트 분할 숫자 등)으로 퀘스트를 생성하면 어떻게 생성될지 시뮬레이션하여 미리 확인한다.
         * @param {ClubQuestsCreateDryRunPostRequest} clubQuestsCreateDryRunPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubQuestsCreateDryRunPost: async (clubQuestsCreateDryRunPostRequest: ClubQuestsCreateDryRunPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clubQuestsCreateDryRunPostRequest' is not null or undefined
            assertParamExists('clubQuestsCreateDryRunPost', 'clubQuestsCreateDryRunPostRequest', clubQuestsCreateDryRunPostRequest)
            const localVarPath = `/clubQuests/create/dryRun`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clubQuestsCreateDryRunPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 구글 폼으로 입력 받은 정보를 기반으로 일상 퀘스트를 즉시 생성하고 알림을 보낸다.
         * @param {CreateAndNotifyDailyClubQuestRequestDTO} createAndNotifyDailyClubQuestRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAndNotifyDailyClubQuest: async (createAndNotifyDailyClubQuestRequestDTO: CreateAndNotifyDailyClubQuestRequestDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAndNotifyDailyClubQuestRequestDTO' is not null or undefined
            assertParamExists('createAndNotifyDailyClubQuest', 'createAndNotifyDailyClubQuestRequestDTO', createAndNotifyDailyClubQuestRequestDTO)
            const localVarPath = `/clubQuests/createAndNotifyDailyClubQuest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAndNotifyDailyClubQuestRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary dryRun 생성 결과를 받아서 실제로 퀘스트를 생성한다.
         * @param {CreateClubQuestRequest} createClubQuestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClubQuest: async (createClubQuestRequest: CreateClubQuestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createClubQuestRequest' is not null or undefined
            assertParamExists('createClubQuest', 'createClubQuestRequest', createClubQuestRequest)
            const localVarPath = `/clubQuests/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createClubQuestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 추천 검색어를 등록한다.
         * @param {AdminCreateSearchPlacePresetRequestDTO} adminCreateSearchPlacePresetRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSearchPreset: async (adminCreateSearchPlacePresetRequestDTO: AdminCreateSearchPlacePresetRequestDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminCreateSearchPlacePresetRequestDTO' is not null or undefined
            assertParamExists('createSearchPreset', 'adminCreateSearchPlacePresetRequestDTO', adminCreateSearchPlacePresetRequestDTO)
            const localVarPath = `/places/searchPresets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminCreateSearchPlacePresetRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 등록된 추천 검색어를 삭제한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSearchPreset: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSearchPreset', 'id', id)
            const localVarPath = `/places/searchPresets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 폐업이 추정되는 장소를 조회한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClosedPlaceCandidate: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getClosedPlaceCandidate', 'id', id)
            const localVarPath = `/closed-place-candidates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary groupId로 해당 그룹의 모든 퀘스트를 조회한다.
         * @param {string} groupId 퀘스트 그룹 식별자
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClubQuestsByGroupId: async (groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getClubQuestsByGroupId', 'groupId', groupId)
            const localVarPath = `/clubQuests/byGroup/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 퀘스트 목록을 커서링 방식으로 조회한다.
         * @summary 커서링 방식의 퀘스트 조회 API
         * @param {string} [cursor] 
         * @param {string} [limit] default 값은 50으로 설정된다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCursoredClubQuestSummaries: async (cursor?: string, limit?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/clubQuestSummaries/cursored`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 등록된 모든 추천 검색어를 가져온다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearchPreset: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/places/searchPresets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 해당 장소를 폐업의 폐업 추정을 무시한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ignoreClosedPlaceCandidate: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ignoreClosedPlaceCandidate', 'id', id)
            const localVarPath = `/closed-place-candidates/{id}/ignore`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 폐업이 추정되는 장소의 리스트를 조회한다.
         * @param {boolean} [isAccessibilityRegistered] 
         * @param {string} [cursor] 
         * @param {string} [limit] default 값은 50으로 설정된다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClosedPlaceCandidates: async (isAccessibilityRegistered?: boolean, cursor?: string, limit?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/closed-place-candidates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isAccessibilityRegistered !== undefined) {
                localVarQueryParameter['isAccessibilityRegistered'] = isAccessibilityRegistered;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 로그인을 한다.
         * @param {LoginPostRequest} loginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginPost: async (loginPostRequest: LoginPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginPostRequest' is not null or undefined
            assertParamExists('loginPost', 'loginPostRequest', loginPostRequest)
            const localVarPath = `/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 특정 장소들을 다른 퀘스트로 이동한다.
         * @param {string} clubQuestId 원본 퀘스트 ID
         * @param {MoveClubQuestTargetPlaceRequest} moveClubQuestTargetPlaceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveClubQuestTargetPlace: async (clubQuestId: string, moveClubQuestTargetPlaceRequest: MoveClubQuestTargetPlaceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clubQuestId' is not null or undefined
            assertParamExists('moveClubQuestTargetPlace', 'clubQuestId', clubQuestId)
            // verify required parameter 'moveClubQuestTargetPlaceRequest' is not null or undefined
            assertParamExists('moveClubQuestTargetPlace', 'moveClubQuestTargetPlaceRequest', moveClubQuestTargetPlaceRequest)
            const localVarPath = `/clubQuests/{clubQuestId}/targetPlaces/move`
                .replace(`{${"clubQuestId"}}`, encodeURIComponent(String(clubQuestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moveClubQuestTargetPlaceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 푸시 알림 스케쥴을 삭제한다.
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsPushSchedulesScheduleIdDelete: async (scheduleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('notificationsPushSchedulesScheduleIdDelete', 'scheduleId', scheduleId)
            const localVarPath = `/notifications/pushSchedules/{scheduleId}`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 푸시 알림 스케쥴을 조회한다.
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsPushSchedulesScheduleIdGet: async (scheduleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('notificationsPushSchedulesScheduleIdGet', 'scheduleId', scheduleId)
            const localVarPath = `/notifications/pushSchedules/{scheduleId}`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 푸시 알림 스케쥴을 수정한다.
         * @param {string} scheduleId 
         * @param {AdminUpdatePushNotificationScheduleRequestDTO} adminUpdatePushNotificationScheduleRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsPushSchedulesScheduleIdPut: async (scheduleId: string, adminUpdatePushNotificationScheduleRequestDTO: AdminUpdatePushNotificationScheduleRequestDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('notificationsPushSchedulesScheduleIdPut', 'scheduleId', scheduleId)
            // verify required parameter 'adminUpdatePushNotificationScheduleRequestDTO' is not null or undefined
            assertParamExists('notificationsPushSchedulesScheduleIdPut', 'adminUpdatePushNotificationScheduleRequestDTO', adminUpdatePushNotificationScheduleRequestDTO)
            const localVarPath = `/notifications/pushSchedules/{scheduleId}`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminUpdatePushNotificationScheduleRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 지정된 지역 내의 장소를 지도 API를 통해 크롤링해서 계단정복지도 서버 DB에 캐싱한다.
         * @param {StartPlaceCrawlingRequestDTO} startPlaceCrawlingRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startPlaceCrawling: async (startPlaceCrawlingRequestDTO: StartPlaceCrawlingRequestDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startPlaceCrawlingRequestDTO' is not null or undefined
            assertParamExists('startPlaceCrawling', 'startPlaceCrawlingRequestDTO', startPlaceCrawlingRequestDTO)
            const localVarPath = `/places/startCrawling`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startPlaceCrawlingRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 해당 장소를 폐업 상태로 변경한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptClosedPlaceCandidate(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminClosedPlaceCandidateDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptClosedPlaceCandidate(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 정보 등록 가능 지역 목록을 조회한다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessibilityAllowedRegionsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccessibilityAllowedRegionDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessibilityAllowedRegionsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 정보 등록 가능 지역을 생성한다.
         * @param {CreateAccessibilityAllowedRegionRequestDTO} createAccessibilityAllowedRegionRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessibilityAllowedRegionsPost(createAccessibilityAllowedRegionRequestDTO: CreateAccessibilityAllowedRegionRequestDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessibilityAllowedRegionsPost(createAccessibilityAllowedRegionRequestDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 정보 등록 가능 지역을 삭제한다.
         * @param {string} regionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessibilityAllowedRegionsRegionIdDelete(regionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessibilityAllowedRegionsRegionIdDelete(regionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 정보 등록 가능 지역을 조회한다.
         * @param {string} regionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessibilityAllowedRegionsRegionIdGet(regionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessibilityAllowedRegionDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessibilityAllowedRegionsRegionIdGet(regionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 배너 생성 등의 상황에서 이미지를 업로드하기 위한 URL을 받아 온다.
         * @param {AdminCreateImageUploadUrlsRequestDTO} adminCreateImageUploadUrlsRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCreateImageUploadUrls(adminCreateImageUploadUrlsRequestDTO: AdminCreateImageUploadUrlsRequestDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminCreateImageUploadUrlsResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCreateImageUploadUrls(adminCreateImageUploadUrlsRequestDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 푸시 알림 스케쥴을 커서링 방식으로 조회한다.
         * @summary 커서링 방식의 푸시 알림 조회.
         * @param {string} [cursor] 
         * @param {string} [limit] default 값은 50으로 설정된다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminGetPushSchedules(cursor?: string, limit?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminListPushNotificationSchedulesResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminGetPushSchedules(cursor, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 유저들에게 push notification을 보낸다.
         * @param {AdminSendPushNotificationRequestDTO} adminSendPushNotificationRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminSendPushNotification(adminSendPushNotificationRequestDTO: AdminSendPushNotificationRequestDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminSendPushNotification(adminSendPushNotificationRequestDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 퀘스트를 삭제한다.
         * @param {string} clubQuestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clubQuestsClubQuestIdDelete(clubQuestId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clubQuestsClubQuestIdDelete(clubQuestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 퀘스트를 조회한다.
         * @param {string} clubQuestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clubQuestsClubQuestIdGet(clubQuestId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClubQuestDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clubQuestsClubQuestIdGet(clubQuestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 점포의 폐점 여부를 저장한다.
         * @param {string} clubQuestId 
         * @param {ClubQuestsClubQuestIdIsClosedPutRequest} clubQuestsClubQuestIdIsClosedPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clubQuestsClubQuestIdIsClosedPut(clubQuestId: string, clubQuestsClubQuestIdIsClosedPutRequest: ClubQuestsClubQuestIdIsClosedPutRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clubQuestsClubQuestIdIsClosedPut(clubQuestId, clubQuestsClubQuestIdIsClosedPutRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 점포의 접근 가능 여부를 저장한다.
         * @param {string} clubQuestId 
         * @param {ClubQuestsClubQuestIdIsNotAccessiblePutRequest} clubQuestsClubQuestIdIsNotAccessiblePutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clubQuestsClubQuestIdIsNotAccessiblePut(clubQuestId: string, clubQuestsClubQuestIdIsNotAccessiblePutRequest: ClubQuestsClubQuestIdIsNotAccessiblePutRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clubQuestsClubQuestIdIsNotAccessiblePut(clubQuestId, clubQuestsClubQuestIdIsNotAccessiblePutRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 퀘스트에서 특정 건물을 제외한다.
         * @param {string} clubQuestId 
         * @param {string} buildingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clubQuestsClubQuestIdTargetBuildingsDelete(clubQuestId: string, buildingId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClubQuestDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clubQuestsClubQuestIdTargetBuildingsDelete(clubQuestId, buildingId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 퀘스트에서 특정 장소를 제외한다.
         * @param {string} clubQuestId 
         * @param {string} placeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clubQuestsClubQuestIdTargetPlacesDelete(clubQuestId: string, placeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClubQuestDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clubQuestsClubQuestIdTargetPlacesDelete(clubQuestId, placeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 주어진 조건(중심 위치, 반경, 퀘스트 분할 숫자 등)으로 퀘스트를 생성하면 어떻게 생성될지 시뮬레이션하여 미리 확인한다.
         * @param {ClubQuestsCreateDryRunPostRequest} clubQuestsCreateDryRunPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clubQuestsCreateDryRunPost(clubQuestsCreateDryRunPostRequest: ClubQuestsCreateDryRunPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClubQuestCreateDryRunResultItemDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clubQuestsCreateDryRunPost(clubQuestsCreateDryRunPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 구글 폼으로 입력 받은 정보를 기반으로 일상 퀘스트를 즉시 생성하고 알림을 보낸다.
         * @param {CreateAndNotifyDailyClubQuestRequestDTO} createAndNotifyDailyClubQuestRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAndNotifyDailyClubQuest(createAndNotifyDailyClubQuestRequestDTO: CreateAndNotifyDailyClubQuestRequestDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAndNotifyDailyClubQuestResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAndNotifyDailyClubQuest(createAndNotifyDailyClubQuestRequestDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary dryRun 생성 결과를 받아서 실제로 퀘스트를 생성한다.
         * @param {CreateClubQuestRequest} createClubQuestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createClubQuest(createClubQuestRequest: CreateClubQuestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateClubQuestResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createClubQuest(createClubQuestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 추천 검색어를 등록한다.
         * @param {AdminCreateSearchPlacePresetRequestDTO} adminCreateSearchPlacePresetRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSearchPreset(adminCreateSearchPlacePresetRequestDTO: AdminCreateSearchPlacePresetRequestDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSearchPreset(adminCreateSearchPlacePresetRequestDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 등록된 추천 검색어를 삭제한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSearchPreset(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSearchPreset(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 폐업이 추정되는 장소를 조회한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClosedPlaceCandidate(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminClosedPlaceCandidateDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClosedPlaceCandidate(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary groupId로 해당 그룹의 모든 퀘스트를 조회한다.
         * @param {string} groupId 퀘스트 그룹 식별자
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClubQuestsByGroupId(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetClubQuestsByGroupIdResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClubQuestsByGroupId(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 퀘스트 목록을 커서링 방식으로 조회한다.
         * @summary 커서링 방식의 퀘스트 조회 API
         * @param {string} [cursor] 
         * @param {string} [limit] default 값은 50으로 설정된다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCursoredClubQuestSummaries(cursor?: string, limit?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCursoredClubQuestSummariesResultDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCursoredClubQuestSummaries(cursor, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 등록된 모든 추천 검색어를 가져온다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSearchPreset(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSearchPreset200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSearchPreset(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 해당 장소를 폐업의 폐업 추정을 무시한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ignoreClosedPlaceCandidate(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminClosedPlaceCandidateDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ignoreClosedPlaceCandidate(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 폐업이 추정되는 장소의 리스트를 조회한다.
         * @param {boolean} [isAccessibilityRegistered] 
         * @param {string} [cursor] 
         * @param {string} [limit] default 값은 50으로 설정된다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listClosedPlaceCandidates(isAccessibilityRegistered?: boolean, cursor?: string, limit?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminListClosedPlaceCandidatesResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listClosedPlaceCandidates(isAccessibilityRegistered, cursor, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 로그인을 한다.
         * @param {LoginPostRequest} loginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginPost(loginPostRequest: LoginPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginPost(loginPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 특정 장소들을 다른 퀘스트로 이동한다.
         * @param {string} clubQuestId 원본 퀘스트 ID
         * @param {MoveClubQuestTargetPlaceRequest} moveClubQuestTargetPlaceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveClubQuestTargetPlace(clubQuestId: string, moveClubQuestTargetPlaceRequest: MoveClubQuestTargetPlaceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MoveClubQuestTargetPlaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveClubQuestTargetPlace(clubQuestId, moveClubQuestTargetPlaceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 푸시 알림 스케쥴을 삭제한다.
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsPushSchedulesScheduleIdDelete(scheduleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsPushSchedulesScheduleIdDelete(scheduleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 푸시 알림 스케쥴을 조회한다.
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsPushSchedulesScheduleIdGet(scheduleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminPushNotificationScheduleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsPushSchedulesScheduleIdGet(scheduleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 푸시 알림 스케쥴을 수정한다.
         * @param {string} scheduleId 
         * @param {AdminUpdatePushNotificationScheduleRequestDTO} adminUpdatePushNotificationScheduleRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsPushSchedulesScheduleIdPut(scheduleId: string, adminUpdatePushNotificationScheduleRequestDTO: AdminUpdatePushNotificationScheduleRequestDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsPushSchedulesScheduleIdPut(scheduleId, adminUpdatePushNotificationScheduleRequestDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 지정된 지역 내의 장소를 지도 API를 통해 크롤링해서 계단정복지도 서버 DB에 캐싱한다.
         * @param {StartPlaceCrawlingRequestDTO} startPlaceCrawlingRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startPlaceCrawling(startPlaceCrawlingRequestDTO: StartPlaceCrawlingRequestDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startPlaceCrawling(startPlaceCrawlingRequestDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary 해당 장소를 폐업 상태로 변경한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptClosedPlaceCandidate(id: string, options?: any): AxiosPromise<AdminClosedPlaceCandidateDTO> {
            return localVarFp.acceptClosedPlaceCandidate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 정보 등록 가능 지역 목록을 조회한다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessibilityAllowedRegionsGet(options?: any): AxiosPromise<Array<AccessibilityAllowedRegionDTO>> {
            return localVarFp.accessibilityAllowedRegionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 정보 등록 가능 지역을 생성한다.
         * @param {CreateAccessibilityAllowedRegionRequestDTO} createAccessibilityAllowedRegionRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessibilityAllowedRegionsPost(createAccessibilityAllowedRegionRequestDTO: CreateAccessibilityAllowedRegionRequestDTO, options?: any): AxiosPromise<void> {
            return localVarFp.accessibilityAllowedRegionsPost(createAccessibilityAllowedRegionRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 정보 등록 가능 지역을 삭제한다.
         * @param {string} regionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessibilityAllowedRegionsRegionIdDelete(regionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.accessibilityAllowedRegionsRegionIdDelete(regionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 정보 등록 가능 지역을 조회한다.
         * @param {string} regionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessibilityAllowedRegionsRegionIdGet(regionId: string, options?: any): AxiosPromise<AccessibilityAllowedRegionDTO> {
            return localVarFp.accessibilityAllowedRegionsRegionIdGet(regionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 배너 생성 등의 상황에서 이미지를 업로드하기 위한 URL을 받아 온다.
         * @param {AdminCreateImageUploadUrlsRequestDTO} adminCreateImageUploadUrlsRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateImageUploadUrls(adminCreateImageUploadUrlsRequestDTO: AdminCreateImageUploadUrlsRequestDTO, options?: any): AxiosPromise<AdminCreateImageUploadUrlsResponseDTO> {
            return localVarFp.adminCreateImageUploadUrls(adminCreateImageUploadUrlsRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 푸시 알림 스케쥴을 커서링 방식으로 조회한다.
         * @summary 커서링 방식의 푸시 알림 조회.
         * @param {string} [cursor] 
         * @param {string} [limit] default 값은 50으로 설정된다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetPushSchedules(cursor?: string, limit?: string, options?: any): AxiosPromise<AdminListPushNotificationSchedulesResponseDTO> {
            return localVarFp.adminGetPushSchedules(cursor, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 유저들에게 push notification을 보낸다.
         * @param {AdminSendPushNotificationRequestDTO} adminSendPushNotificationRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminSendPushNotification(adminSendPushNotificationRequestDTO: AdminSendPushNotificationRequestDTO, options?: any): AxiosPromise<void> {
            return localVarFp.adminSendPushNotification(adminSendPushNotificationRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 퀘스트를 삭제한다.
         * @param {string} clubQuestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubQuestsClubQuestIdDelete(clubQuestId: string, options?: any): AxiosPromise<void> {
            return localVarFp.clubQuestsClubQuestIdDelete(clubQuestId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 퀘스트를 조회한다.
         * @param {string} clubQuestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubQuestsClubQuestIdGet(clubQuestId: string, options?: any): AxiosPromise<ClubQuestDTO> {
            return localVarFp.clubQuestsClubQuestIdGet(clubQuestId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 점포의 폐점 여부를 저장한다.
         * @param {string} clubQuestId 
         * @param {ClubQuestsClubQuestIdIsClosedPutRequest} clubQuestsClubQuestIdIsClosedPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubQuestsClubQuestIdIsClosedPut(clubQuestId: string, clubQuestsClubQuestIdIsClosedPutRequest: ClubQuestsClubQuestIdIsClosedPutRequest, options?: any): AxiosPromise<void> {
            return localVarFp.clubQuestsClubQuestIdIsClosedPut(clubQuestId, clubQuestsClubQuestIdIsClosedPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 점포의 접근 가능 여부를 저장한다.
         * @param {string} clubQuestId 
         * @param {ClubQuestsClubQuestIdIsNotAccessiblePutRequest} clubQuestsClubQuestIdIsNotAccessiblePutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubQuestsClubQuestIdIsNotAccessiblePut(clubQuestId: string, clubQuestsClubQuestIdIsNotAccessiblePutRequest: ClubQuestsClubQuestIdIsNotAccessiblePutRequest, options?: any): AxiosPromise<void> {
            return localVarFp.clubQuestsClubQuestIdIsNotAccessiblePut(clubQuestId, clubQuestsClubQuestIdIsNotAccessiblePutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 퀘스트에서 특정 건물을 제외한다.
         * @param {string} clubQuestId 
         * @param {string} buildingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubQuestsClubQuestIdTargetBuildingsDelete(clubQuestId: string, buildingId: string, options?: any): AxiosPromise<ClubQuestDTO> {
            return localVarFp.clubQuestsClubQuestIdTargetBuildingsDelete(clubQuestId, buildingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 퀘스트에서 특정 장소를 제외한다.
         * @param {string} clubQuestId 
         * @param {string} placeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubQuestsClubQuestIdTargetPlacesDelete(clubQuestId: string, placeId: string, options?: any): AxiosPromise<ClubQuestDTO> {
            return localVarFp.clubQuestsClubQuestIdTargetPlacesDelete(clubQuestId, placeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 주어진 조건(중심 위치, 반경, 퀘스트 분할 숫자 등)으로 퀘스트를 생성하면 어떻게 생성될지 시뮬레이션하여 미리 확인한다.
         * @param {ClubQuestsCreateDryRunPostRequest} clubQuestsCreateDryRunPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clubQuestsCreateDryRunPost(clubQuestsCreateDryRunPostRequest: ClubQuestsCreateDryRunPostRequest, options?: any): AxiosPromise<Array<ClubQuestCreateDryRunResultItemDTO>> {
            return localVarFp.clubQuestsCreateDryRunPost(clubQuestsCreateDryRunPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 구글 폼으로 입력 받은 정보를 기반으로 일상 퀘스트를 즉시 생성하고 알림을 보낸다.
         * @param {CreateAndNotifyDailyClubQuestRequestDTO} createAndNotifyDailyClubQuestRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAndNotifyDailyClubQuest(createAndNotifyDailyClubQuestRequestDTO: CreateAndNotifyDailyClubQuestRequestDTO, options?: any): AxiosPromise<CreateAndNotifyDailyClubQuestResponseDTO> {
            return localVarFp.createAndNotifyDailyClubQuest(createAndNotifyDailyClubQuestRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary dryRun 생성 결과를 받아서 실제로 퀘스트를 생성한다.
         * @param {CreateClubQuestRequest} createClubQuestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClubQuest(createClubQuestRequest: CreateClubQuestRequest, options?: any): AxiosPromise<CreateClubQuestResponseDTO> {
            return localVarFp.createClubQuest(createClubQuestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 추천 검색어를 등록한다.
         * @param {AdminCreateSearchPlacePresetRequestDTO} adminCreateSearchPlacePresetRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSearchPreset(adminCreateSearchPlacePresetRequestDTO: AdminCreateSearchPlacePresetRequestDTO, options?: any): AxiosPromise<void> {
            return localVarFp.createSearchPreset(adminCreateSearchPlacePresetRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 등록된 추천 검색어를 삭제한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSearchPreset(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSearchPreset(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 폐업이 추정되는 장소를 조회한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClosedPlaceCandidate(id: string, options?: any): AxiosPromise<AdminClosedPlaceCandidateDTO> {
            return localVarFp.getClosedPlaceCandidate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary groupId로 해당 그룹의 모든 퀘스트를 조회한다.
         * @param {string} groupId 퀘스트 그룹 식별자
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClubQuestsByGroupId(groupId: string, options?: any): AxiosPromise<GetClubQuestsByGroupIdResult> {
            return localVarFp.getClubQuestsByGroupId(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 퀘스트 목록을 커서링 방식으로 조회한다.
         * @summary 커서링 방식의 퀘스트 조회 API
         * @param {string} [cursor] 
         * @param {string} [limit] default 값은 50으로 설정된다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCursoredClubQuestSummaries(cursor?: string, limit?: string, options?: any): AxiosPromise<GetCursoredClubQuestSummariesResultDTO> {
            return localVarFp.getCursoredClubQuestSummaries(cursor, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 등록된 모든 추천 검색어를 가져온다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearchPreset(options?: any): AxiosPromise<GetSearchPreset200Response> {
            return localVarFp.getSearchPreset(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 해당 장소를 폐업의 폐업 추정을 무시한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ignoreClosedPlaceCandidate(id: string, options?: any): AxiosPromise<AdminClosedPlaceCandidateDTO> {
            return localVarFp.ignoreClosedPlaceCandidate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 폐업이 추정되는 장소의 리스트를 조회한다.
         * @param {boolean} [isAccessibilityRegistered] 
         * @param {string} [cursor] 
         * @param {string} [limit] default 값은 50으로 설정된다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClosedPlaceCandidates(isAccessibilityRegistered?: boolean, cursor?: string, limit?: string, options?: any): AxiosPromise<AdminListClosedPlaceCandidatesResponseDTO> {
            return localVarFp.listClosedPlaceCandidates(isAccessibilityRegistered, cursor, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 로그인을 한다.
         * @param {LoginPostRequest} loginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginPost(loginPostRequest: LoginPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.loginPost(loginPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 특정 장소들을 다른 퀘스트로 이동한다.
         * @param {string} clubQuestId 원본 퀘스트 ID
         * @param {MoveClubQuestTargetPlaceRequest} moveClubQuestTargetPlaceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveClubQuestTargetPlace(clubQuestId: string, moveClubQuestTargetPlaceRequest: MoveClubQuestTargetPlaceRequest, options?: any): AxiosPromise<MoveClubQuestTargetPlaceResponse> {
            return localVarFp.moveClubQuestTargetPlace(clubQuestId, moveClubQuestTargetPlaceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 푸시 알림 스케쥴을 삭제한다.
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsPushSchedulesScheduleIdDelete(scheduleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.notificationsPushSchedulesScheduleIdDelete(scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 푸시 알림 스케쥴을 조회한다.
         * @param {string} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsPushSchedulesScheduleIdGet(scheduleId: string, options?: any): AxiosPromise<AdminPushNotificationScheduleDTO> {
            return localVarFp.notificationsPushSchedulesScheduleIdGet(scheduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 푸시 알림 스케쥴을 수정한다.
         * @param {string} scheduleId 
         * @param {AdminUpdatePushNotificationScheduleRequestDTO} adminUpdatePushNotificationScheduleRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsPushSchedulesScheduleIdPut(scheduleId: string, adminUpdatePushNotificationScheduleRequestDTO: AdminUpdatePushNotificationScheduleRequestDTO, options?: any): AxiosPromise<void> {
            return localVarFp.notificationsPushSchedulesScheduleIdPut(scheduleId, adminUpdatePushNotificationScheduleRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 지정된 지역 내의 장소를 지도 API를 통해 크롤링해서 계단정복지도 서버 DB에 캐싱한다.
         * @param {StartPlaceCrawlingRequestDTO} startPlaceCrawlingRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startPlaceCrawling(startPlaceCrawlingRequestDTO: StartPlaceCrawlingRequestDTO, options?: any): AxiosPromise<void> {
            return localVarFp.startPlaceCrawling(startPlaceCrawlingRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary 해당 장소를 폐업 상태로 변경한다.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public acceptClosedPlaceCandidate(id: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).acceptClosedPlaceCandidate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 정보 등록 가능 지역 목록을 조회한다.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accessibilityAllowedRegionsGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accessibilityAllowedRegionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 정보 등록 가능 지역을 생성한다.
     * @param {CreateAccessibilityAllowedRegionRequestDTO} createAccessibilityAllowedRegionRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accessibilityAllowedRegionsPost(createAccessibilityAllowedRegionRequestDTO: CreateAccessibilityAllowedRegionRequestDTO, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accessibilityAllowedRegionsPost(createAccessibilityAllowedRegionRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 정보 등록 가능 지역을 삭제한다.
     * @param {string} regionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accessibilityAllowedRegionsRegionIdDelete(regionId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accessibilityAllowedRegionsRegionIdDelete(regionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 정보 등록 가능 지역을 조회한다.
     * @param {string} regionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accessibilityAllowedRegionsRegionIdGet(regionId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accessibilityAllowedRegionsRegionIdGet(regionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 배너 생성 등의 상황에서 이미지를 업로드하기 위한 URL을 받아 온다.
     * @param {AdminCreateImageUploadUrlsRequestDTO} adminCreateImageUploadUrlsRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public adminCreateImageUploadUrls(adminCreateImageUploadUrlsRequestDTO: AdminCreateImageUploadUrlsRequestDTO, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).adminCreateImageUploadUrls(adminCreateImageUploadUrlsRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 푸시 알림 스케쥴을 커서링 방식으로 조회한다.
     * @summary 커서링 방식의 푸시 알림 조회.
     * @param {string} [cursor] 
     * @param {string} [limit] default 값은 50으로 설정된다.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public adminGetPushSchedules(cursor?: string, limit?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).adminGetPushSchedules(cursor, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 유저들에게 push notification을 보낸다.
     * @param {AdminSendPushNotificationRequestDTO} adminSendPushNotificationRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public adminSendPushNotification(adminSendPushNotificationRequestDTO: AdminSendPushNotificationRequestDTO, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).adminSendPushNotification(adminSendPushNotificationRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 퀘스트를 삭제한다.
     * @param {string} clubQuestId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public clubQuestsClubQuestIdDelete(clubQuestId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).clubQuestsClubQuestIdDelete(clubQuestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 퀘스트를 조회한다.
     * @param {string} clubQuestId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public clubQuestsClubQuestIdGet(clubQuestId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).clubQuestsClubQuestIdGet(clubQuestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 점포의 폐점 여부를 저장한다.
     * @param {string} clubQuestId 
     * @param {ClubQuestsClubQuestIdIsClosedPutRequest} clubQuestsClubQuestIdIsClosedPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public clubQuestsClubQuestIdIsClosedPut(clubQuestId: string, clubQuestsClubQuestIdIsClosedPutRequest: ClubQuestsClubQuestIdIsClosedPutRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).clubQuestsClubQuestIdIsClosedPut(clubQuestId, clubQuestsClubQuestIdIsClosedPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 점포의 접근 가능 여부를 저장한다.
     * @param {string} clubQuestId 
     * @param {ClubQuestsClubQuestIdIsNotAccessiblePutRequest} clubQuestsClubQuestIdIsNotAccessiblePutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public clubQuestsClubQuestIdIsNotAccessiblePut(clubQuestId: string, clubQuestsClubQuestIdIsNotAccessiblePutRequest: ClubQuestsClubQuestIdIsNotAccessiblePutRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).clubQuestsClubQuestIdIsNotAccessiblePut(clubQuestId, clubQuestsClubQuestIdIsNotAccessiblePutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 퀘스트에서 특정 건물을 제외한다.
     * @param {string} clubQuestId 
     * @param {string} buildingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public clubQuestsClubQuestIdTargetBuildingsDelete(clubQuestId: string, buildingId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).clubQuestsClubQuestIdTargetBuildingsDelete(clubQuestId, buildingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 퀘스트에서 특정 장소를 제외한다.
     * @param {string} clubQuestId 
     * @param {string} placeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public clubQuestsClubQuestIdTargetPlacesDelete(clubQuestId: string, placeId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).clubQuestsClubQuestIdTargetPlacesDelete(clubQuestId, placeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 주어진 조건(중심 위치, 반경, 퀘스트 분할 숫자 등)으로 퀘스트를 생성하면 어떻게 생성될지 시뮬레이션하여 미리 확인한다.
     * @param {ClubQuestsCreateDryRunPostRequest} clubQuestsCreateDryRunPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public clubQuestsCreateDryRunPost(clubQuestsCreateDryRunPostRequest: ClubQuestsCreateDryRunPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).clubQuestsCreateDryRunPost(clubQuestsCreateDryRunPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 구글 폼으로 입력 받은 정보를 기반으로 일상 퀘스트를 즉시 생성하고 알림을 보낸다.
     * @param {CreateAndNotifyDailyClubQuestRequestDTO} createAndNotifyDailyClubQuestRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createAndNotifyDailyClubQuest(createAndNotifyDailyClubQuestRequestDTO: CreateAndNotifyDailyClubQuestRequestDTO, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createAndNotifyDailyClubQuest(createAndNotifyDailyClubQuestRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary dryRun 생성 결과를 받아서 실제로 퀘스트를 생성한다.
     * @param {CreateClubQuestRequest} createClubQuestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createClubQuest(createClubQuestRequest: CreateClubQuestRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createClubQuest(createClubQuestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 추천 검색어를 등록한다.
     * @param {AdminCreateSearchPlacePresetRequestDTO} adminCreateSearchPlacePresetRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createSearchPreset(adminCreateSearchPlacePresetRequestDTO: AdminCreateSearchPlacePresetRequestDTO, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createSearchPreset(adminCreateSearchPlacePresetRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 등록된 추천 검색어를 삭제한다.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteSearchPreset(id: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteSearchPreset(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 폐업이 추정되는 장소를 조회한다.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getClosedPlaceCandidate(id: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getClosedPlaceCandidate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary groupId로 해당 그룹의 모든 퀘스트를 조회한다.
     * @param {string} groupId 퀘스트 그룹 식별자
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getClubQuestsByGroupId(groupId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getClubQuestsByGroupId(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 퀘스트 목록을 커서링 방식으로 조회한다.
     * @summary 커서링 방식의 퀘스트 조회 API
     * @param {string} [cursor] 
     * @param {string} [limit] default 값은 50으로 설정된다.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCursoredClubQuestSummaries(cursor?: string, limit?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCursoredClubQuestSummaries(cursor, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 등록된 모든 추천 검색어를 가져온다.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSearchPreset(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSearchPreset(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 해당 장소를 폐업의 폐업 추정을 무시한다.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public ignoreClosedPlaceCandidate(id: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).ignoreClosedPlaceCandidate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 폐업이 추정되는 장소의 리스트를 조회한다.
     * @param {boolean} [isAccessibilityRegistered] 
     * @param {string} [cursor] 
     * @param {string} [limit] default 값은 50으로 설정된다.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listClosedPlaceCandidates(isAccessibilityRegistered?: boolean, cursor?: string, limit?: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listClosedPlaceCandidates(isAccessibilityRegistered, cursor, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 로그인을 한다.
     * @param {LoginPostRequest} loginPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public loginPost(loginPostRequest: LoginPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).loginPost(loginPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 특정 장소들을 다른 퀘스트로 이동한다.
     * @param {string} clubQuestId 원본 퀘스트 ID
     * @param {MoveClubQuestTargetPlaceRequest} moveClubQuestTargetPlaceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public moveClubQuestTargetPlace(clubQuestId: string, moveClubQuestTargetPlaceRequest: MoveClubQuestTargetPlaceRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).moveClubQuestTargetPlace(clubQuestId, moveClubQuestTargetPlaceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 푸시 알림 스케쥴을 삭제한다.
     * @param {string} scheduleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public notificationsPushSchedulesScheduleIdDelete(scheduleId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).notificationsPushSchedulesScheduleIdDelete(scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 푸시 알림 스케쥴을 조회한다.
     * @param {string} scheduleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public notificationsPushSchedulesScheduleIdGet(scheduleId: string, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).notificationsPushSchedulesScheduleIdGet(scheduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 푸시 알림 스케쥴을 수정한다.
     * @param {string} scheduleId 
     * @param {AdminUpdatePushNotificationScheduleRequestDTO} adminUpdatePushNotificationScheduleRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public notificationsPushSchedulesScheduleIdPut(scheduleId: string, adminUpdatePushNotificationScheduleRequestDTO: AdminUpdatePushNotificationScheduleRequestDTO, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).notificationsPushSchedulesScheduleIdPut(scheduleId, adminUpdatePushNotificationScheduleRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 지정된 지역 내의 장소를 지도 API를 통해 크롤링해서 계단정복지도 서버 DB에 캐싱한다.
     * @param {StartPlaceCrawlingRequestDTO} startPlaceCrawlingRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public startPlaceCrawling(startPlaceCrawlingRequestDTO: StartPlaceCrawlingRequestDTO, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).startPlaceCrawling(startPlaceCrawlingRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HomeAnnouncementApi - axios parameter creator
 * @export
 */
export const HomeAnnouncementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 홈 공지사항을 생성한다.
         * @param {AdminCreateHomeAnnouncementRequestDTO} adminCreateHomeAnnouncementRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateHomeAnnouncement: async (adminCreateHomeAnnouncementRequestDTO: AdminCreateHomeAnnouncementRequestDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminCreateHomeAnnouncementRequestDTO' is not null or undefined
            assertParamExists('adminCreateHomeAnnouncement', 'adminCreateHomeAnnouncementRequestDTO', adminCreateHomeAnnouncementRequestDTO)
            const localVarPath = `/home-announcements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminCreateHomeAnnouncementRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 홈 공지사항을 삭제한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteHomeAnnouncement: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminDeleteHomeAnnouncement', 'id', id)
            const localVarPath = `/home-announcements/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 홈 공지사항 목록을 조회한다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminListHomeAnnouncements: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/home-announcements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HomeAnnouncementApi - functional programming interface
 * @export
 */
export const HomeAnnouncementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HomeAnnouncementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 홈 공지사항을 생성한다.
         * @param {AdminCreateHomeAnnouncementRequestDTO} adminCreateHomeAnnouncementRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCreateHomeAnnouncement(adminCreateHomeAnnouncementRequestDTO: AdminCreateHomeAnnouncementRequestDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCreateHomeAnnouncement(adminCreateHomeAnnouncementRequestDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 홈 공지사항을 삭제한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDeleteHomeAnnouncement(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDeleteHomeAnnouncement(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 홈 공지사항 목록을 조회한다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminListHomeAnnouncements(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminListHomeAnnouncementsResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminListHomeAnnouncements(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HomeAnnouncementApi - factory interface
 * @export
 */
export const HomeAnnouncementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HomeAnnouncementApiFp(configuration)
    return {
        /**
         * 
         * @summary 홈 공지사항을 생성한다.
         * @param {AdminCreateHomeAnnouncementRequestDTO} adminCreateHomeAnnouncementRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateHomeAnnouncement(adminCreateHomeAnnouncementRequestDTO: AdminCreateHomeAnnouncementRequestDTO, options?: any): AxiosPromise<void> {
            return localVarFp.adminCreateHomeAnnouncement(adminCreateHomeAnnouncementRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 홈 공지사항을 삭제한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteHomeAnnouncement(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.adminDeleteHomeAnnouncement(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 홈 공지사항 목록을 조회한다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminListHomeAnnouncements(options?: any): AxiosPromise<AdminListHomeAnnouncementsResponseDTO> {
            return localVarFp.adminListHomeAnnouncements(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HomeAnnouncementApi - object-oriented interface
 * @export
 * @class HomeAnnouncementApi
 * @extends {BaseAPI}
 */
export class HomeAnnouncementApi extends BaseAPI {
    /**
     * 
     * @summary 홈 공지사항을 생성한다.
     * @param {AdminCreateHomeAnnouncementRequestDTO} adminCreateHomeAnnouncementRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HomeAnnouncementApi
     */
    public adminCreateHomeAnnouncement(adminCreateHomeAnnouncementRequestDTO: AdminCreateHomeAnnouncementRequestDTO, options?: AxiosRequestConfig) {
        return HomeAnnouncementApiFp(this.configuration).adminCreateHomeAnnouncement(adminCreateHomeAnnouncementRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 홈 공지사항을 삭제한다.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HomeAnnouncementApi
     */
    public adminDeleteHomeAnnouncement(id: string, options?: AxiosRequestConfig) {
        return HomeAnnouncementApiFp(this.configuration).adminDeleteHomeAnnouncement(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 홈 공지사항 목록을 조회한다.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HomeAnnouncementApi
     */
    public adminListHomeAnnouncements(options?: AxiosRequestConfig) {
        return HomeAnnouncementApiFp(this.configuration).adminListHomeAnnouncements(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HomeRecommendedContentApi - axios parameter creator
 * @export
 */
export const HomeRecommendedContentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 홈 추천 컨텐츠를 생성한다.
         * @param {AdminCreateHomeRecommendedContentRequestDTO} adminCreateHomeRecommendedContentRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateHomeRecommendedContent: async (adminCreateHomeRecommendedContentRequestDTO: AdminCreateHomeRecommendedContentRequestDTO, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminCreateHomeRecommendedContentRequestDTO' is not null or undefined
            assertParamExists('adminCreateHomeRecommendedContent', 'adminCreateHomeRecommendedContentRequestDTO', adminCreateHomeRecommendedContentRequestDTO)
            const localVarPath = `/home-recommended-contents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminCreateHomeRecommendedContentRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 홈 추천 컨텐츠를 삭제한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteHomeRecommendedContent: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminDeleteHomeRecommendedContent', 'id', id)
            const localVarPath = `/home-recommended-contents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 홈 추천 컨텐츠 목록을 조회한다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminListHomeRecommendedContents: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/home-recommended-contents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HomeRecommendedContentApi - functional programming interface
 * @export
 */
export const HomeRecommendedContentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HomeRecommendedContentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 홈 추천 컨텐츠를 생성한다.
         * @param {AdminCreateHomeRecommendedContentRequestDTO} adminCreateHomeRecommendedContentRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCreateHomeRecommendedContent(adminCreateHomeRecommendedContentRequestDTO: AdminCreateHomeRecommendedContentRequestDTO, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCreateHomeRecommendedContent(adminCreateHomeRecommendedContentRequestDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 홈 추천 컨텐츠를 삭제한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDeleteHomeRecommendedContent(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDeleteHomeRecommendedContent(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 홈 추천 컨텐츠 목록을 조회한다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminListHomeRecommendedContents(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminListHomeRecommendedContentsResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminListHomeRecommendedContents(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HomeRecommendedContentApi - factory interface
 * @export
 */
export const HomeRecommendedContentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HomeRecommendedContentApiFp(configuration)
    return {
        /**
         * 
         * @summary 홈 추천 컨텐츠를 생성한다.
         * @param {AdminCreateHomeRecommendedContentRequestDTO} adminCreateHomeRecommendedContentRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateHomeRecommendedContent(adminCreateHomeRecommendedContentRequestDTO: AdminCreateHomeRecommendedContentRequestDTO, options?: any): AxiosPromise<void> {
            return localVarFp.adminCreateHomeRecommendedContent(adminCreateHomeRecommendedContentRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 홈 추천 컨텐츠를 삭제한다.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteHomeRecommendedContent(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.adminDeleteHomeRecommendedContent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 홈 추천 컨텐츠 목록을 조회한다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminListHomeRecommendedContents(options?: any): AxiosPromise<AdminListHomeRecommendedContentsResponseDTO> {
            return localVarFp.adminListHomeRecommendedContents(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HomeRecommendedContentApi - object-oriented interface
 * @export
 * @class HomeRecommendedContentApi
 * @extends {BaseAPI}
 */
export class HomeRecommendedContentApi extends BaseAPI {
    /**
     * 
     * @summary 홈 추천 컨텐츠를 생성한다.
     * @param {AdminCreateHomeRecommendedContentRequestDTO} adminCreateHomeRecommendedContentRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HomeRecommendedContentApi
     */
    public adminCreateHomeRecommendedContent(adminCreateHomeRecommendedContentRequestDTO: AdminCreateHomeRecommendedContentRequestDTO, options?: AxiosRequestConfig) {
        return HomeRecommendedContentApiFp(this.configuration).adminCreateHomeRecommendedContent(adminCreateHomeRecommendedContentRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 홈 추천 컨텐츠를 삭제한다.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HomeRecommendedContentApi
     */
    public adminDeleteHomeRecommendedContent(id: string, options?: AxiosRequestConfig) {
        return HomeRecommendedContentApiFp(this.configuration).adminDeleteHomeRecommendedContent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 홈 추천 컨텐츠 목록을 조회한다.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HomeRecommendedContentApi
     */
    public adminListHomeRecommendedContents(options?: AxiosRequestConfig) {
        return HomeRecommendedContentApiFp(this.configuration).adminListHomeRecommendedContents(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlaceCategoryCacheApi - axios parameter creator
 * @export
 */
export const PlaceCategoryCacheApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 장소 카테고리 캐시를 수동으로 생성한다.
         * @param {AdminCreatePlaceCategoryCacheRequestDto} adminCreatePlaceCategoryCacheRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlaceCategoryCache: async (adminCreatePlaceCategoryCacheRequestDto: AdminCreatePlaceCategoryCacheRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminCreatePlaceCategoryCacheRequestDto' is not null or undefined
            assertParamExists('createPlaceCategoryCache', 'adminCreatePlaceCategoryCacheRequestDto', adminCreatePlaceCategoryCacheRequestDto)
            const localVarPath = `/place-category-caches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminCreatePlaceCategoryCacheRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 장소 카테고리 캐시를 삭제한다. 삭제 후 다음 조회시 AI가 다시 카테고리를 판정한다.
         * @param {string} id PlaceCategoryCache ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaceCategoryCache: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePlaceCategoryCache', 'id', id)
            const localVarPath = `/place-category-caches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 장소 카테고리 캐시를 단건 조회한다.
         * @param {string} id PlaceCategoryCache ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaceCategoryCache: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPlaceCategoryCache', 'id', id)
            const localVarPath = `/place-category-caches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 장소 카테고리 캐시 목록을 조회한다.
         * @param {string} [cursor] 페이지네이션 커서
         * @param {number} [limit] 페이지당 항목 수 (기본값 20)
         * @param {PlaceCategoryDto} [placeCategory] 카테고리별 필터링
         * @param {string} [categoryStringContains] categoryString 검색 (포함 검색)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlaceCategoryCaches: async (cursor?: string, limit?: number, placeCategory?: PlaceCategoryDto, categoryStringContains?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/place-category-caches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (placeCategory !== undefined) {
                localVarQueryParameter['placeCategory'] = placeCategory;
            }

            if (categoryStringContains !== undefined) {
                localVarQueryParameter['categoryStringContains'] = categoryStringContains;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 장소 카테고리 캐시를 수정한다.
         * @param {string} id PlaceCategoryCache ID
         * @param {AdminUpdatePlaceCategoryCacheRequestDto} adminUpdatePlaceCategoryCacheRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlaceCategoryCache: async (id: string, adminUpdatePlaceCategoryCacheRequestDto: AdminUpdatePlaceCategoryCacheRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePlaceCategoryCache', 'id', id)
            // verify required parameter 'adminUpdatePlaceCategoryCacheRequestDto' is not null or undefined
            assertParamExists('updatePlaceCategoryCache', 'adminUpdatePlaceCategoryCacheRequestDto', adminUpdatePlaceCategoryCacheRequestDto)
            const localVarPath = `/place-category-caches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminUpdatePlaceCategoryCacheRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaceCategoryCacheApi - functional programming interface
 * @export
 */
export const PlaceCategoryCacheApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlaceCategoryCacheApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 장소 카테고리 캐시를 수동으로 생성한다.
         * @param {AdminCreatePlaceCategoryCacheRequestDto} adminCreatePlaceCategoryCacheRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlaceCategoryCache(adminCreatePlaceCategoryCacheRequestDto: AdminCreatePlaceCategoryCacheRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminPlaceCategoryCacheDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPlaceCategoryCache(adminCreatePlaceCategoryCacheRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 장소 카테고리 캐시를 삭제한다. 삭제 후 다음 조회시 AI가 다시 카테고리를 판정한다.
         * @param {string} id PlaceCategoryCache ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePlaceCategoryCache(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePlaceCategoryCache(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 장소 카테고리 캐시를 단건 조회한다.
         * @param {string} id PlaceCategoryCache ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlaceCategoryCache(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminPlaceCategoryCacheDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlaceCategoryCache(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 장소 카테고리 캐시 목록을 조회한다.
         * @param {string} [cursor] 페이지네이션 커서
         * @param {number} [limit] 페이지당 항목 수 (기본값 20)
         * @param {PlaceCategoryDto} [placeCategory] 카테고리별 필터링
         * @param {string} [categoryStringContains] categoryString 검색 (포함 검색)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPlaceCategoryCaches(cursor?: string, limit?: number, placeCategory?: PlaceCategoryDto, categoryStringContains?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminListPlaceCategoryCachesResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPlaceCategoryCaches(cursor, limit, placeCategory, categoryStringContains, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 장소 카테고리 캐시를 수정한다.
         * @param {string} id PlaceCategoryCache ID
         * @param {AdminUpdatePlaceCategoryCacheRequestDto} adminUpdatePlaceCategoryCacheRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePlaceCategoryCache(id: string, adminUpdatePlaceCategoryCacheRequestDto: AdminUpdatePlaceCategoryCacheRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminPlaceCategoryCacheDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePlaceCategoryCache(id, adminUpdatePlaceCategoryCacheRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlaceCategoryCacheApi - factory interface
 * @export
 */
export const PlaceCategoryCacheApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlaceCategoryCacheApiFp(configuration)
    return {
        /**
         * 
         * @summary 장소 카테고리 캐시를 수동으로 생성한다.
         * @param {AdminCreatePlaceCategoryCacheRequestDto} adminCreatePlaceCategoryCacheRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlaceCategoryCache(adminCreatePlaceCategoryCacheRequestDto: AdminCreatePlaceCategoryCacheRequestDto, options?: any): AxiosPromise<AdminPlaceCategoryCacheDto> {
            return localVarFp.createPlaceCategoryCache(adminCreatePlaceCategoryCacheRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 장소 카테고리 캐시를 삭제한다. 삭제 후 다음 조회시 AI가 다시 카테고리를 판정한다.
         * @param {string} id PlaceCategoryCache ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaceCategoryCache(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePlaceCategoryCache(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 장소 카테고리 캐시를 단건 조회한다.
         * @param {string} id PlaceCategoryCache ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaceCategoryCache(id: string, options?: any): AxiosPromise<AdminPlaceCategoryCacheDto> {
            return localVarFp.getPlaceCategoryCache(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 장소 카테고리 캐시 목록을 조회한다.
         * @param {string} [cursor] 페이지네이션 커서
         * @param {number} [limit] 페이지당 항목 수 (기본값 20)
         * @param {PlaceCategoryDto} [placeCategory] 카테고리별 필터링
         * @param {string} [categoryStringContains] categoryString 검색 (포함 검색)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlaceCategoryCaches(cursor?: string, limit?: number, placeCategory?: PlaceCategoryDto, categoryStringContains?: string, options?: any): AxiosPromise<AdminListPlaceCategoryCachesResponseDto> {
            return localVarFp.listPlaceCategoryCaches(cursor, limit, placeCategory, categoryStringContains, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 장소 카테고리 캐시를 수정한다.
         * @param {string} id PlaceCategoryCache ID
         * @param {AdminUpdatePlaceCategoryCacheRequestDto} adminUpdatePlaceCategoryCacheRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlaceCategoryCache(id: string, adminUpdatePlaceCategoryCacheRequestDto: AdminUpdatePlaceCategoryCacheRequestDto, options?: any): AxiosPromise<AdminPlaceCategoryCacheDto> {
            return localVarFp.updatePlaceCategoryCache(id, adminUpdatePlaceCategoryCacheRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlaceCategoryCacheApi - object-oriented interface
 * @export
 * @class PlaceCategoryCacheApi
 * @extends {BaseAPI}
 */
export class PlaceCategoryCacheApi extends BaseAPI {
    /**
     * 
     * @summary 장소 카테고리 캐시를 수동으로 생성한다.
     * @param {AdminCreatePlaceCategoryCacheRequestDto} adminCreatePlaceCategoryCacheRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceCategoryCacheApi
     */
    public createPlaceCategoryCache(adminCreatePlaceCategoryCacheRequestDto: AdminCreatePlaceCategoryCacheRequestDto, options?: AxiosRequestConfig) {
        return PlaceCategoryCacheApiFp(this.configuration).createPlaceCategoryCache(adminCreatePlaceCategoryCacheRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 장소 카테고리 캐시를 삭제한다. 삭제 후 다음 조회시 AI가 다시 카테고리를 판정한다.
     * @param {string} id PlaceCategoryCache ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceCategoryCacheApi
     */
    public deletePlaceCategoryCache(id: string, options?: AxiosRequestConfig) {
        return PlaceCategoryCacheApiFp(this.configuration).deletePlaceCategoryCache(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 장소 카테고리 캐시를 단건 조회한다.
     * @param {string} id PlaceCategoryCache ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceCategoryCacheApi
     */
    public getPlaceCategoryCache(id: string, options?: AxiosRequestConfig) {
        return PlaceCategoryCacheApiFp(this.configuration).getPlaceCategoryCache(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 장소 카테고리 캐시 목록을 조회한다.
     * @param {string} [cursor] 페이지네이션 커서
     * @param {number} [limit] 페이지당 항목 수 (기본값 20)
     * @param {PlaceCategoryDto} [placeCategory] 카테고리별 필터링
     * @param {string} [categoryStringContains] categoryString 검색 (포함 검색)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceCategoryCacheApi
     */
    public listPlaceCategoryCaches(cursor?: string, limit?: number, placeCategory?: PlaceCategoryDto, categoryStringContains?: string, options?: AxiosRequestConfig) {
        return PlaceCategoryCacheApiFp(this.configuration).listPlaceCategoryCaches(cursor, limit, placeCategory, categoryStringContains, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 장소 카테고리 캐시를 수정한다.
     * @param {string} id PlaceCategoryCache ID
     * @param {AdminUpdatePlaceCategoryCacheRequestDto} adminUpdatePlaceCategoryCacheRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceCategoryCacheApi
     */
    public updatePlaceCategoryCache(id: string, adminUpdatePlaceCategoryCacheRequestDto: AdminUpdatePlaceCategoryCacheRequestDto, options?: AxiosRequestConfig) {
        return PlaceCategoryCacheApiFp(this.configuration).updatePlaceCategoryCache(id, adminUpdatePlaceCategoryCacheRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlaceListApi - axios parameter creator
 * @export
 */
export const PlaceListApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 저장 리스트를 생성한다.
         * @param {AdminCreatePlaceListRequestDto} adminCreatePlaceListRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlaceList: async (adminCreatePlaceListRequestDto: AdminCreatePlaceListRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminCreatePlaceListRequestDto' is not null or undefined
            assertParamExists('createPlaceList', 'adminCreatePlaceListRequestDto', adminCreatePlaceListRequestDto)
            const localVarPath = `/place-lists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminCreatePlaceListRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 저장 리스트를 삭제한다.
         * @param {string} id PlaceList ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaceList: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePlaceList', 'id', id)
            const localVarPath = `/place-lists/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 저장 리스트 상세를 조회한다.
         * @param {string} id PlaceList ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaceList: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPlaceList', 'id', id)
            const localVarPath = `/place-lists/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 저장 리스트 목록을 조회한다. NORMAL 타입만 조회한다.
         * @param {string} [cursor] 페이지네이션 커서
         * @param {number} [limit] 페이지당 항목 수 (기본값 20)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlaceLists: async (cursor?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/place-lists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 키워드로 장소를 검색한다.
         * @param {AdminSearchPlacesByKeywordRequestDto} adminSearchPlacesByKeywordRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPlacesByKeyword: async (adminSearchPlacesByKeywordRequestDto: AdminSearchPlacesByKeywordRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminSearchPlacesByKeywordRequestDto' is not null or undefined
            assertParamExists('searchPlacesByKeyword', 'adminSearchPlacesByKeywordRequestDto', adminSearchPlacesByKeywordRequestDto)
            const localVarPath = `/places/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminSearchPlacesByKeywordRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 저장 리스트를 수정한다.
         * @param {string} id PlaceList ID
         * @param {AdminUpdatePlaceListRequestDto} adminUpdatePlaceListRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlaceList: async (id: string, adminUpdatePlaceListRequestDto: AdminUpdatePlaceListRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePlaceList', 'id', id)
            // verify required parameter 'adminUpdatePlaceListRequestDto' is not null or undefined
            assertParamExists('updatePlaceList', 'adminUpdatePlaceListRequestDto', adminUpdatePlaceListRequestDto)
            const localVarPath = `/place-lists/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Admin required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminUpdatePlaceListRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaceListApi - functional programming interface
 * @export
 */
export const PlaceListApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlaceListApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 저장 리스트를 생성한다.
         * @param {AdminCreatePlaceListRequestDto} adminCreatePlaceListRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlaceList(adminCreatePlaceListRequestDto: AdminCreatePlaceListRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminPlaceListDetailDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPlaceList(adminCreatePlaceListRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 저장 리스트를 삭제한다.
         * @param {string} id PlaceList ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePlaceList(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePlaceList(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 저장 리스트 상세를 조회한다.
         * @param {string} id PlaceList ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlaceList(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminPlaceListDetailDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlaceList(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 저장 리스트 목록을 조회한다. NORMAL 타입만 조회한다.
         * @param {string} [cursor] 페이지네이션 커서
         * @param {number} [limit] 페이지당 항목 수 (기본값 20)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPlaceLists(cursor?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminListPlaceListsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPlaceLists(cursor, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 키워드로 장소를 검색한다.
         * @param {AdminSearchPlacesByKeywordRequestDto} adminSearchPlacesByKeywordRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPlacesByKeyword(adminSearchPlacesByKeywordRequestDto: AdminSearchPlacesByKeywordRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminSearchPlacesByKeywordResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPlacesByKeyword(adminSearchPlacesByKeywordRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 저장 리스트를 수정한다.
         * @param {string} id PlaceList ID
         * @param {AdminUpdatePlaceListRequestDto} adminUpdatePlaceListRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePlaceList(id: string, adminUpdatePlaceListRequestDto: AdminUpdatePlaceListRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminPlaceListDetailDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePlaceList(id, adminUpdatePlaceListRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlaceListApi - factory interface
 * @export
 */
export const PlaceListApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlaceListApiFp(configuration)
    return {
        /**
         * 
         * @summary 저장 리스트를 생성한다.
         * @param {AdminCreatePlaceListRequestDto} adminCreatePlaceListRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlaceList(adminCreatePlaceListRequestDto: AdminCreatePlaceListRequestDto, options?: any): AxiosPromise<AdminPlaceListDetailDto> {
            return localVarFp.createPlaceList(adminCreatePlaceListRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 저장 리스트를 삭제한다.
         * @param {string} id PlaceList ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaceList(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePlaceList(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 저장 리스트 상세를 조회한다.
         * @param {string} id PlaceList ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaceList(id: string, options?: any): AxiosPromise<AdminPlaceListDetailDto> {
            return localVarFp.getPlaceList(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 저장 리스트 목록을 조회한다. NORMAL 타입만 조회한다.
         * @param {string} [cursor] 페이지네이션 커서
         * @param {number} [limit] 페이지당 항목 수 (기본값 20)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlaceLists(cursor?: string, limit?: number, options?: any): AxiosPromise<AdminListPlaceListsResponseDto> {
            return localVarFp.listPlaceLists(cursor, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 키워드로 장소를 검색한다.
         * @param {AdminSearchPlacesByKeywordRequestDto} adminSearchPlacesByKeywordRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPlacesByKeyword(adminSearchPlacesByKeywordRequestDto: AdminSearchPlacesByKeywordRequestDto, options?: any): AxiosPromise<AdminSearchPlacesByKeywordResponseDto> {
            return localVarFp.searchPlacesByKeyword(adminSearchPlacesByKeywordRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 저장 리스트를 수정한다.
         * @param {string} id PlaceList ID
         * @param {AdminUpdatePlaceListRequestDto} adminUpdatePlaceListRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlaceList(id: string, adminUpdatePlaceListRequestDto: AdminUpdatePlaceListRequestDto, options?: any): AxiosPromise<AdminPlaceListDetailDto> {
            return localVarFp.updatePlaceList(id, adminUpdatePlaceListRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlaceListApi - object-oriented interface
 * @export
 * @class PlaceListApi
 * @extends {BaseAPI}
 */
export class PlaceListApi extends BaseAPI {
    /**
     * 
     * @summary 저장 리스트를 생성한다.
     * @param {AdminCreatePlaceListRequestDto} adminCreatePlaceListRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceListApi
     */
    public createPlaceList(adminCreatePlaceListRequestDto: AdminCreatePlaceListRequestDto, options?: AxiosRequestConfig) {
        return PlaceListApiFp(this.configuration).createPlaceList(adminCreatePlaceListRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 저장 리스트를 삭제한다.
     * @param {string} id PlaceList ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceListApi
     */
    public deletePlaceList(id: string, options?: AxiosRequestConfig) {
        return PlaceListApiFp(this.configuration).deletePlaceList(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 저장 리스트 상세를 조회한다.
     * @param {string} id PlaceList ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceListApi
     */
    public getPlaceList(id: string, options?: AxiosRequestConfig) {
        return PlaceListApiFp(this.configuration).getPlaceList(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 저장 리스트 목록을 조회한다. NORMAL 타입만 조회한다.
     * @param {string} [cursor] 페이지네이션 커서
     * @param {number} [limit] 페이지당 항목 수 (기본값 20)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceListApi
     */
    public listPlaceLists(cursor?: string, limit?: number, options?: AxiosRequestConfig) {
        return PlaceListApiFp(this.configuration).listPlaceLists(cursor, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 키워드로 장소를 검색한다.
     * @param {AdminSearchPlacesByKeywordRequestDto} adminSearchPlacesByKeywordRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceListApi
     */
    public searchPlacesByKeyword(adminSearchPlacesByKeywordRequestDto: AdminSearchPlacesByKeywordRequestDto, options?: AxiosRequestConfig) {
        return PlaceListApiFp(this.configuration).searchPlacesByKeyword(adminSearchPlacesByKeywordRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 저장 리스트를 수정한다.
     * @param {string} id PlaceList ID
     * @param {AdminUpdatePlaceListRequestDto} adminUpdatePlaceListRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceListApi
     */
    public updatePlaceList(id: string, adminUpdatePlaceListRequestDto: AdminUpdatePlaceListRequestDto, options?: AxiosRequestConfig) {
        return PlaceListApiFp(this.configuration).updatePlaceList(id, adminUpdatePlaceListRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}


